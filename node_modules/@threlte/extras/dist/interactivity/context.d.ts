import { type CurrentWritable, type createRawEventDispatcher } from '@threlte/core';
import { Vector2, Raycaster } from 'three';
import type { IntersectionEvent, ThrelteEvents, DomEvent } from './types';
export type FilterFunction = (items: THREE.Intersection[], context: InteractivityContext) => THREE.Intersection[];
export type ComputeFunction = (event: DomEvent, context: InteractivityContext) => void;
export type InteractivityOptions = {
    enabled?: boolean;
    /**
     * The compute function is responsible for updating the state of the interactivity plugin.
     * It needs to set up the raycaster and the pointer vector. If no compute function is provided,
     * the plugin will use the default compute function.
     */
    compute?: ComputeFunction;
    target?: HTMLElement;
    /**
     * The filter function is responsible for filtering and sorting the
     * intersections. By default, the intersections are sorted by distance. If no
     * filter function is provided, the plugin will use the default filter function.
     */
    filter?: FilterFunction;
};
export type InteractivityContext = {
    enabled: CurrentWritable<boolean>;
    target: CurrentWritable<HTMLElement | undefined>;
    pointer: CurrentWritable<Vector2>;
    pointerOverTarget: CurrentWritable<boolean>;
    lastEvent: DomEvent | undefined;
    raycaster: Raycaster;
    initialClick: [x: number, y: number];
    initialHits: THREE.Object3D[];
    hovered: Map<string, IntersectionEvent<DomEvent>>;
    interactiveObjects: THREE.Object3D[];
    compute: ComputeFunction;
    filter?: FilterFunction;
};
export declare const getInteractivityContext: () => InteractivityContext;
export declare const setInteractivityContext: (options?: InteractivityOptions) => InteractivityContext;
interface HandlerContext {
    dispatchers: WeakMap<THREE.Object3D, ReturnType<typeof createRawEventDispatcher<ThrelteEvents>>>;
}
export declare const getHandlerContext: () => HandlerContext;
export declare const setHandlerContext: () => void;
export {};
