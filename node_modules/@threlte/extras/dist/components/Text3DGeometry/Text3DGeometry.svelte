<script>import { T, asyncWritable, forwardEventHandlers, useLoader } from '@threlte/core';
import { derived, writable } from 'svelte/store';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { toCreasedNormals } from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { useSuspense } from '../../suspense/useSuspense';
export let text;
export let font = 'https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json';
export let size = undefined;
export let height = undefined;
export let curveSegments = undefined;
export let bevelEnabled = undefined;
export let bevelThickness = undefined;
export let bevelSize = undefined;
export let bevelOffset = undefined;
export let bevelSegments = undefined;
export let smooth = undefined;
export let depth = undefined;
export let extrudePath = undefined;
export let steps = undefined;
export let UVGenerator = undefined;
const suspend = useSuspense();
$: loadedFont = suspend(typeof font === 'string'
    ? useLoader(FontLoader).load(font)
    : asyncWritable(new Promise((resolve) => resolve(font))));
$: options = writable({
    text,
    size,
    height,
    curveSegments,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments
});
$: baseGeometry = derived([loadedFont, options], ([font, options]) => {
    if (!font)
        return;
    return new TextGeometry(options.text, {
        font,
        size: options.size,
        height: options.height,
        curveSegments: options.curveSegments,
        bevelEnabled: options.bevelEnabled,
        bevelThickness: options.bevelThickness,
        bevelSize: options.bevelSize,
        bevelOffset: options.bevelOffset,
        bevelSegments: options.bevelSegments,
        depth,
        extrudePath,
        steps,
        UVGenerator
    });
});
$: smoothStore = writable(smooth);
$: creasedGeometry = derived([baseGeometry, smoothStore], ([baseGeometry, smooth]) => {
    if (!baseGeometry)
        return;
    if (smooth === 0)
        return baseGeometry;
    return toCreasedNormals(baseGeometry, smooth);
});
const component = forwardEventHandlers();
</script>

{#if $creasedGeometry}
  <T
    is={$creasedGeometry}
    bind:this={$component}
    let:ref
  >
    <slot {ref} />
  </T>
{/if}
