<!--

@component `<XR />` is a WebXR manager that configures your scene for XR rendering and interaction.

This should be placed within a Threlte `<Canvas />`.

```svelte
  <XR
    foveation={1}
    frameRate={90}
    referenceSpace='local-floor'
    on:sessionstart={(event: XREvent<XRManagerEvent>) => {}}
    on:sessionend={(event: XREvent<XRManagerEvent>) => {}}
    on:visibilitychange={(event: XREvent<XRSessionEvent>) => {}}
    on:inputsourceschange={(event: XREvent<XRSessionEvent>) => {}}
  />
```

-->
<script>import { onMount } from "svelte";
import { createRawEventDispatcher, useThrelte, watch } from "@threlte/core";
import {
  isHandTracking,
  isPresenting,
  referenceSpaceType,
  session,
  xr as xrStore
} from "../internal/stores";
import { setupRaf } from "../internal/setupRaf";
import { setupHeadset } from "../internal/setupHeadset";
import { setupControllers } from "../internal/setupControllers";
import { setupHands } from "../internal/setupHands";
export let foveation = 1;
export let frameRate = void 0;
export let referenceSpace = "local-floor";
const dispatch = createRawEventDispatcher();
const { renderer, renderMode } = useThrelte();
const { xr } = renderer;
let originalRenderMode = $renderMode;
setupRaf();
setupHeadset();
setupControllers();
setupHands();
const handleSessionStart = () => {
  isPresenting.set(true);
  dispatch("sessionstart", { type: "sessionstart", target: $session });
};
const handleSessionEnd = () => {
  dispatch("sessionend", { type: "sessionend", target: $session });
  isPresenting.set(false);
  session.set(void 0);
};
const handleVisibilityChange = (event) => {
  dispatch("visibilitychange", { ...event, target: $session });
};
const handleInputSourcesChange = (event) => {
  $isHandTracking = Object.values(event.session.inputSources).some((source) => source.hand);
  dispatch("inputsourceschange", { ...event, target: $session });
};
const handleFramerateChange = (event) => {
  dispatch("visibilitychange", { ...event, target: $session });
};
const updateTargetFrameRate = (frameRate2) => {
  if (frameRate2 === void 0)
    return;
  try {
    $session?.updateTargetFrameRate(frameRate2);
  } catch {
  }
};
watch(session, (currentSession) => {
  if (currentSession === void 0)
    return;
  currentSession.addEventListener("visibilitychange", handleVisibilityChange);
  currentSession.addEventListener("inputsourceschange", handleInputSourcesChange);
  currentSession.addEventListener("frameratechange", handleFramerateChange);
  xr.setFoveation(foveation);
  updateTargetFrameRate(frameRate);
  return () => {
    currentSession.removeEventListener("visibilitychange", handleVisibilityChange);
    currentSession.removeEventListener("inputsourceschange", handleInputSourcesChange);
    currentSession.removeEventListener("frameratechange", handleFramerateChange);
  };
});
watch(isPresenting, (presenting) => {
  if (presenting) {
    originalRenderMode = renderMode.current;
    renderMode.set("always");
  } else {
    renderMode.set(originalRenderMode);
  }
});
onMount(() => {
  $xrStore = xr;
  xr.enabled = true;
  xr.addEventListener("sessionstart", handleSessionStart);
  xr.addEventListener("sessionend", handleSessionEnd);
  return () => {
    $xrStore = void 0;
    xr.enabled = false;
    xr.removeEventListener("sessionstart", handleSessionStart);
    xr.removeEventListener("sessionend", handleSessionEnd);
  };
});
$:
  updateTargetFrameRate(frameRate);
$:
  xr.setFoveation(foveation);
$: {
  xr.setReferenceSpaceType(referenceSpace);
  $referenceSpaceType = referenceSpace;
}
</script>

{#if $isPresenting}
  <slot />
{:else}
  <slot name="fallback" />
{/if}
