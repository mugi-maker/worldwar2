import { Raycaster } from 'three';
import { currentWritable, watch } from '@threlte/core';
import { setTeleportContext, getTeleportContext, getHandContext } from './context';
import { injectTeleportControlsPlugin } from './plugin';
import { defaultComputeFunction } from './compute';
import { setHandContext } from './context';
import { setupTeleportControls } from './setup';
import { teleportState } from '../../internal/stores';
let controlsCounter = 0;
export const teleportControls = (handedness, options) => {
    if (getTeleportContext() === undefined) {
        injectTeleportControlsPlugin();
        setTeleportContext({
            interactiveObjects: [],
            surfaces: new Map(),
            blockers: new Map(),
            dispatchers: new WeakMap(),
            raycaster: new Raycaster(),
            compute: options?.compute ?? defaultComputeFunction
        });
    }
    const context = getTeleportContext();
    if (getHandContext(handedness) === undefined) {
        const enabled = options?.enabled ?? true;
        controlsCounter += enabled ? 1 : -1;
        const ctx = {
            hand: handedness,
            active: currentWritable(false),
            enabled: currentWritable(enabled),
            hovered: currentWritable(undefined)
        };
        setHandContext(handedness, ctx);
        setupTeleportControls(context, ctx, options?.fixedStep);
    }
    const handContext = getHandContext(handedness);
    watch(handContext.enabled, (enabled) => {
        controlsCounter += enabled ? 1 : -1;
        teleportState.update((value) => {
            value[handedness].enabled = controlsCounter > 0;
            return value;
        });
    });
    watch(handContext.active, (hovering) => {
        teleportState.update((value) => {
            value[handedness].hovering = hovering;
            return value;
        });
    });
    return {
        enabled: handContext.enabled,
        hovered: handContext.hovered,
        active: handContext.active
    };
};
