{
  "version": 3,
  "sources": ["../../mitt/src/index.ts", "../../@threlte/core/dist/frame-scheduling/DAG.js", "../../@threlte/core/dist/frame-scheduling/Task.js", "../../@threlte/core/dist/frame-scheduling/Stage.js", "../../@threlte/core/dist/frame-scheduling/Scheduler.js", "../../@threlte/core/dist/lib/storeUtils.js", "../../@threlte/core/dist/lib/defaultCamera.js", "../../@threlte/core/dist/hooks/legacy/utils.js", "../../@threlte/core/dist/lib/contexts.js", "../../@threlte/core/dist/lib/browser.js", "../../@threlte/core/dist/hooks/useParentSize.js", "../../@threlte/core/dist/lib/createObjectStore.js", "../../@threlte/core/dist/hooks/useThrelte.js", "../../@threlte/core/dist/hooks/useParent.js", "../../@threlte/core/dist/internal/HierarchicalObject.svelte", "../../@threlte/core/dist/internal/SceneGraphObject.svelte", "../../@threlte/core/dist/lib/cache.js", "../../@threlte/core/dist/lib/revision.js", "../../@threlte/core/dist/lib/useRenderer.js", "../../@threlte/core/dist/hooks/useThrelteInternal.js", "../../@threlte/core/dist/Canvas.svelte", "../../@threlte/core/dist/internal/DisposableObject.svelte", "../../@threlte/core/dist/components/T/utils/utils.js", "../../@threlte/core/dist/components/T/utils/resolvePropertyPath.js", "../../@threlte/core/dist/components/T/utils/useAttach.js", "../../@threlte/core/dist/components/T/utils/useCamera.js", "../../@threlte/core/dist/lib/createRawEventDispatcher.js", "../../@threlte/core/dist/components/T/utils/useCreateEvent.js", "../../@threlte/core/dist/components/T/utils/useEvents.js", "../../@threlte/core/dist/components/T/utils/usePlugins.js", "../../@threlte/core/dist/components/T/utils/useProps.js", "../../@threlte/core/dist/components/T/T.svelte", "../../@threlte/core/dist/components/T/T.js", "../../@threlte/core/dist/plugins/injectPlugin.js", "../../@threlte/core/dist/plugins/createPlugin.js", "../../@threlte/core/dist/hooks/useTask.js", "../../@threlte/core/dist/hooks/useStage.js", "../../@threlte/core/dist/hooks/useThrelteUserContext.js", "../../@threlte/core/dist/hooks/legacy/useFrame.js", "../../@threlte/core/dist/hooks/legacy/useRender.js", "../../@threlte/core/dist/lib/asyncWritable.js", "../../@threlte/core/dist/hooks/useLoader.js", "../../@threlte/core/dist/lib/forwardEventHandlers.js"],
  "sourcesContent": ["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n", "import mitt from 'mitt';\nexport class DAG {\n    allVertices = {};\n    /** Nodes that are fully unlinked */\n    isolatedVertices = {};\n    connectedVertices = {};\n    sortedConnectedValues = [];\n    needsSort = false;\n    emitter = mitt();\n    emit = this.emitter.emit.bind(this.emitter);\n    on = this.emitter.on.bind(this.emitter);\n    off = this.emitter.off.bind(this.emitter);\n    get sortedVertices() {\n        return this.mapNodes((value) => value);\n    }\n    moveToIsolated(key) {\n        const vertex = this.connectedVertices[key];\n        if (!vertex)\n            return;\n        this.isolatedVertices[key] = vertex;\n        delete this.connectedVertices[key];\n    }\n    moveToConnected(key) {\n        const vertex = this.isolatedVertices[key];\n        if (!vertex)\n            return;\n        this.connectedVertices[key] = vertex;\n        delete this.isolatedVertices[key];\n    }\n    getKey = (v) => {\n        if (typeof v === 'object') {\n            return v.key;\n        }\n        return v;\n    };\n    add(key, value, options) {\n        if (this.allVertices[key] && this.allVertices[key].value !== undefined) {\n            throw new Error(`A node with the key ${key.toString()} already exists`);\n        }\n        let vertex = this.allVertices[key];\n        if (!vertex) {\n            vertex = {\n                value: value,\n                previous: new Set(),\n                next: new Set()\n            };\n            // add the vertex to the list of all vertices\n            this.allVertices[key] = vertex;\n        }\n        else if (vertex.value === undefined) {\n            vertex.value = value;\n        }\n        // if another node referenced this node before, we have inverse links\n        const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;\n        if (!options?.after && !options?.before && !hasEdges) {\n            // the node we're about to add is fully unlinked\n            this.isolatedVertices[key] = vertex;\n            this.emit('node:added', {\n                key,\n                type: 'isolated',\n                value\n            });\n            return;\n        }\n        else {\n            this.connectedVertices[key] = vertex;\n        }\n        if (options?.after) {\n            const afterArr = Array.isArray(options.after) ? options.after : [options.after];\n            // we need to update the vertex to include the new \"after\" nodes\n            afterArr.forEach((after) => {\n                vertex.previous.add(this.getKey(after));\n            });\n            afterArr.forEach((after) => {\n                const afterKey = this.getKey(after);\n                // we get the vertex from the list of all vertices\n                const linkedAfter = this.allVertices[afterKey];\n                if (!linkedAfter) {\n                    // if it doesn't exist, we create it\n                    this.allVertices[afterKey] = {\n                        value: undefined,\n                        previous: new Set(),\n                        next: new Set([key])\n                    };\n                    this.connectedVertices[afterKey] = this.allVertices[afterKey];\n                }\n                else {\n                    // if it does exist, we update it\n                    linkedAfter.next.add(key);\n                    // we might need to move the vertex from isolated to connected\n                    this.moveToConnected(afterKey);\n                }\n            });\n        }\n        if (options?.before) {\n            const beforeArr = Array.isArray(options.before) ? options.before : [options.before];\n            // we need to update the vertex to include the new \"before\" nodes\n            beforeArr.forEach((before) => {\n                vertex.next.add(this.getKey(before));\n            });\n            beforeArr.forEach((before) => {\n                const beforeKey = this.getKey(before);\n                // we get the vertex from the list of all vertices\n                const linkedBefore = this.allVertices[beforeKey];\n                if (!linkedBefore) {\n                    // if it doesn't exist, we create it\n                    this.allVertices[beforeKey] = {\n                        value: undefined,\n                        previous: new Set([key]),\n                        next: new Set()\n                    };\n                    this.connectedVertices[beforeKey] = this.allVertices[beforeKey];\n                }\n                else {\n                    // if it does exist, we update it\n                    linkedBefore.previous.add(key);\n                    // we might need to move the vertex from isolated to connected\n                    this.moveToConnected(beforeKey);\n                }\n            });\n        }\n        this.emit('node:added', {\n            key,\n            type: 'connected',\n            value\n        });\n        // Mark the graph as needing a re-sort\n        this.needsSort = true;\n    }\n    remove(key) {\n        const removeKey = this.getKey(key);\n        // check if it's an unlinked vertex\n        const unlinkedVertex = this.isolatedVertices[removeKey];\n        if (unlinkedVertex) {\n            delete this.isolatedVertices[removeKey];\n            delete this.allVertices[removeKey];\n            this.emit('node:removed', {\n                key: removeKey,\n                type: 'isolated'\n            });\n            return;\n        }\n        // if it's not, it's a bit more complicated\n        const linkedVertex = this.connectedVertices[removeKey];\n        if (!linkedVertex) {\n            // The node does not exist in the graph.\n            return;\n        }\n        // Update the 'next' nodes that this node points to\n        linkedVertex.next.forEach((nextKey) => {\n            const nextVertex = this.connectedVertices[nextKey];\n            if (nextVertex) {\n                nextVertex.previous.delete(removeKey);\n                if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {\n                    this.moveToIsolated(nextKey);\n                }\n            }\n        });\n        // Update the 'previous' nodes that point to this node\n        linkedVertex.previous.forEach((prevKey) => {\n            const prevVertex = this.connectedVertices[prevKey];\n            if (prevVertex) {\n                prevVertex.next.delete(removeKey);\n                if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {\n                    this.moveToIsolated(prevKey);\n                }\n            }\n        });\n        // Finally, remove the node from the graph\n        delete this.connectedVertices[removeKey];\n        delete this.allVertices[removeKey];\n        this.emit('node:removed', {\n            key: removeKey,\n            type: 'connected'\n        });\n        // Mark the graph as needing a re-sort\n        this.needsSort = true;\n    }\n    mapNodes(callback) {\n        if (this.needsSort) {\n            this.sort();\n        }\n        const result = [];\n        this.forEachNode((value, index) => {\n            result.push(callback(value, index));\n        });\n        return result;\n    }\n    forEachNode(callback) {\n        if (this.needsSort) {\n            this.sort();\n        }\n        let index = 0;\n        for (; index < this.sortedConnectedValues.length; index++) {\n            callback(this.sortedConnectedValues[index], index);\n        }\n        Reflect.ownKeys(this.isolatedVertices).forEach((key) => {\n            const vertex = this.isolatedVertices[key];\n            if (vertex.value !== undefined)\n                callback(vertex.value, index++);\n        });\n    }\n    getValueByKey(key) {\n        return this.allVertices[key]?.value;\n    }\n    getKeyByValue(value) {\n        return (Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ??\n            Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value));\n    }\n    sort() {\n        const inDegree = new Map();\n        const zeroInDegreeQueue = [];\n        const result = [];\n        // we're only interested in vertices that have a value\n        const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {\n            const vertex = this.connectedVertices[key];\n            return vertex.value !== undefined;\n        });\n        // Initialize inDegree (count of incoming edges) for each vertex\n        connectedVertexKeysWithValues.forEach((vertex) => {\n            inDegree.set(vertex, 0);\n        });\n        // Calculate inDegree for each vertex\n        connectedVertexKeysWithValues.forEach((vertexKey) => {\n            const vertex = this.connectedVertices[vertexKey];\n            vertex.next.forEach((next) => {\n                // check if \"next\" vertex has a value\n                const nextVertex = this.connectedVertices[next];\n                if (!nextVertex)\n                    return;\n                inDegree.set(next, (inDegree.get(next) || 0) + 1);\n            });\n        });\n        // Enqueue vertices with inDegree 0\n        inDegree.forEach((degree, value) => {\n            if (degree === 0) {\n                zeroInDegreeQueue.push(value);\n            }\n        });\n        // Process vertices with inDegree 0 and decrease inDegree of adjacent vertices\n        while (zeroInDegreeQueue.length > 0) {\n            const vertexKey = zeroInDegreeQueue.shift();\n            result.push(vertexKey);\n            const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);\n            if (v) {\n                this.connectedVertices[v]?.next.forEach((adjVertex) => {\n                    const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;\n                    inDegree.set(adjVertex, adjVertexInDegree);\n                    if (adjVertexInDegree === 0) {\n                        zeroInDegreeQueue.push(adjVertex);\n                    }\n                });\n            }\n        }\n        // Check for cycles in the graph\n        if (result.length !== connectedVertexKeysWithValues.length) {\n            throw new Error('The graph contains a cycle, and thus can not be sorted topologically.');\n        }\n        const filterUndefined = (value) => value !== undefined;\n        this.sortedConnectedValues = result\n            .map((key) => this.connectedVertices[key].value)\n            .filter(filterUndefined);\n        this.needsSort = false;\n    }\n    clear() {\n        this.allVertices = {};\n        this.isolatedVertices = {};\n        this.connectedVertices = {};\n        this.sortedConnectedValues = [];\n        this.needsSort = false;\n    }\n    static isKey(value) {\n        return typeof value === 'string' || typeof value === 'symbol';\n    }\n    static isValue(value) {\n        return typeof value === 'object' && 'key' in value;\n    }\n}\n", "export class Task {\n    key;\n    stage;\n    callback;\n    runTask = true;\n    stop() {\n        this.runTask = false;\n    }\n    start() {\n        this.runTask = true;\n    }\n    constructor(stage, key, callback) {\n        this.stage = stage;\n        this.key = key;\n        this.callback = callback;\n    }\n    run(delta) {\n        if (!this.runTask)\n            return;\n        this.callback(delta);\n    }\n}\n", "import { DAG } from './DAG';\nimport { Task } from './Task';\n/**\n * A Stage is a collection of steps. The steps are run in a topological sort\n * order.\n */\nexport class Stage extends DAG {\n    key;\n    scheduler;\n    get tasks() {\n        return this.sortedVertices;\n    }\n    callback = (_, r) => r();\n    constructor(scheduler, key, callback) {\n        super();\n        this.scheduler = scheduler;\n        this.key = key;\n        if (callback)\n            this.callback = callback.bind(this);\n    }\n    createTask(key, callback, options) {\n        const task = new Task(this, key, callback);\n        this.add(key, task, options);\n        return task;\n    }\n    getTask(key) {\n        return this.getValueByKey(key);\n    }\n    removeTask = this.remove.bind(this);\n    run(delta) {\n        this.callback(delta, (deltaOverride) => {\n            this.forEachNode((task) => {\n                task.run(deltaOverride ?? delta);\n            });\n        });\n    }\n    runWithTiming(delta) {\n        const taskTimings = {};\n        this.callback(delta, (deltaOverride) => {\n            this.forEachNode((task) => {\n                const start = performance.now();\n                task.run(deltaOverride ?? delta);\n                const duration = performance.now() - start;\n                taskTimings[task.key] = duration;\n            });\n        });\n        return taskTimings;\n    }\n    getSchedule() {\n        return this.mapNodes((l) => l.key.toString());\n    }\n}\n", "import { DAG } from './DAG';\nimport { Stage } from './Stage';\n/**\n * A Scheduler is responsible for running stages. It runs the stages in a\n * requestAnimationFrame stage.\n */\nexport class Scheduler extends DAG {\n    lastTime = performance.now();\n    clampDeltaTo = 0.1;\n    get stages() {\n        return this.sortedVertices;\n    }\n    constructor(options) {\n        super();\n        if (options?.clampDeltaTo)\n            this.clampDeltaTo = options.clampDeltaTo;\n        this.run = this.run.bind(this);\n    }\n    createStage(key, options) {\n        const stage = new Stage(this, key, options?.callback);\n        this.add(key, stage, {\n            after: options?.after,\n            before: options?.before\n        });\n        return stage;\n    }\n    getStage(key) {\n        return this.getValueByKey(key);\n    }\n    removeStage = this.remove.bind(this);\n    /**\n     * Runs all the stages in the scheduler.\n     *\n     * @param time The time in milliseconds since the start of the program.\n     */\n    run(time) {\n        const delta = time - this.lastTime;\n        this.forEachNode((stage) => {\n            // we pass the delta as seconds, not milliseconds,\n            // this is in line with how Three.js, Unity and\n            // other game engines do it. On top of that, it\n            // needs to be clamped to prevent large delta\n            // values from causing large jumps in the game\n            // state.\n            stage.run(Math.min(delta / 1000, this.clampDeltaTo));\n        });\n        this.lastTime = time;\n    }\n    runWithTiming(time) {\n        const delta = time - this.lastTime;\n        const stageTimings = {};\n        const start = performance.now();\n        this.forEachNode((stage) => {\n            const start = performance.now();\n            const taskTimings = stage.runWithTiming(Math.min(delta / 1000, this.clampDeltaTo));\n            const duration = performance.now() - start;\n            stageTimings[stage.key.toString()] = {\n                duration,\n                tasks: taskTimings\n            };\n        });\n        return {\n            total: performance.now() - start,\n            stages: stageTimings\n        };\n    }\n    getSchedule(include = {\n        tasks: true\n    }) {\n        return {\n            stages: this.mapNodes((stage) => {\n                if (stage === undefined)\n                    throw new Error('Stage not found');\n                return {\n                    key: stage.key.toString(),\n                    ...{ tasks: include.tasks ? stage.getSchedule() : undefined }\n                };\n            })\n        };\n    }\n    dispose() {\n        this.clear();\n    }\n}\n", "import { onDestroy } from 'svelte';\nimport { derived, writable } from 'svelte/store';\n/**\n * ### `watch`\n *\n * Watch a single store or multiple stores and call a callback when they change to trigger side effects.\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\n *\n * ```ts\n * const store = writable(0)\n *\n * watch(store, (value) => {\n * \tconsole.log(value) // 0\n * })\n * ```\n *\n * You can also watch multiple stores:\n *\n * ```ts\n * const store1 = writable(0)\n * const store2 = writable(1)\n *\n * watch([store1, store2], ([value1, value2]) => {\n * \tconsole.log(value1, value2) // 0 1\n * })\n * ```\n *\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\n *\n * ```ts\n * const store = writable(0)\n *\n * watch(store, (value) => {\n * \tconsole.log(value) // 0\n * \treturn () => {\n * \t\tconsole.log('cleanup')\n * \t}\n * })\n * ```\n *\n * @param stores\n * @param callback\n */\nexport const watch = (stores, callback) => {\n    const d = derived(stores, (values) => {\n        return values;\n    });\n    let cleanupFn;\n    const unsubscribe = d.subscribe(async (values) => {\n        if (cleanupFn)\n            cleanupFn();\n        const fn = await callback(values);\n        if (fn)\n            cleanupFn = fn;\n    });\n    onDestroy(() => {\n        unsubscribe();\n        if (cleanupFn)\n            cleanupFn();\n    });\n};\nexport function memoize(stores, transform) {\n    const obj = {\n        current: undefined\n    };\n    watch(stores, (v) => {\n        obj.current = transform ? transform(v) : v;\n    });\n    return obj;\n}\n/**\n * ### `currentWritable`\n *\n * A writable store that also has a `current` property that is updated synchronously.\n * For use in non-reactive contexts e.g. loops where unwrapping a store every frame is expensive.\n *\n * ```ts\n * const store = currentWritable(0)\n *\n * useTask(() => {\n * \tconsole.log(store.current) // 0\n * })\n *\n * @param value\n * @returns\n */\nexport const currentWritable = (value) => {\n    const store = writable(value);\n    const extendedWritable = {\n        set: (value) => {\n            extendedWritable.current = value;\n            store.set(value);\n        },\n        subscribe: store.subscribe,\n        update: (fn) => {\n            const newValue = fn(extendedWritable.current);\n            extendedWritable.current = newValue;\n            store.set(newValue);\n        },\n        current: value\n    };\n    return extendedWritable;\n};\n", "import { PerspectiveCamera } from 'three';\nimport { watch } from './storeUtils';\nconst defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1000);\ndefaultCamera.position.z = 5;\ndefaultCamera.lookAt(0, 0, 0);\nexport const getDefaultCamera = () => defaultCamera;\nexport const setDefaultCameraAspectOnSizeChange = (ctx) => {\n    watch(ctx.size, (size) => {\n        if (ctx.camera.current === defaultCamera) {\n            const cam = ctx.camera.current;\n            cam.aspect = size.width / size.height;\n            cam.updateProjectionMatrix();\n            ctx.invalidate();\n        }\n    });\n};\n", "import { getContext, setContext } from 'svelte';\nexport const orderToKey = (order) => `useFrame-order-${order.toString()}`;\nconst useLegacyFrameCompatibilityContextKey = Symbol('use-legacy-frame-compatibility-context');\nexport const injectLegacyFrameCompatibilityContext = () => {\n    const ctx = {\n        useFrameOrders: [],\n        useRenderOrders: []\n    };\n    setContext(useLegacyFrameCompatibilityContextKey, ctx);\n    return ctx;\n};\nexport const useLegacyFrameCompatibilityContext = () => {\n    const ctx = getContext(useLegacyFrameCompatibilityContextKey);\n    if (ctx === undefined) {\n        throw new Error('No legacy frame compatibility context found, are you using this hook inside of <Canvas>?');\n    }\n    return ctx;\n};\n", "import { setContext, tick } from 'svelte';\nimport { derived } from 'svelte/store';\nimport { Scene } from 'three';\nimport { Scheduler } from '../frame-scheduling';\nimport { getDefaultCamera, setDefaultCameraAspectOnSizeChange } from './defaultCamera';\nimport { currentWritable } from './storeUtils';\nimport { injectLegacyFrameCompatibilityContext } from '../hooks/legacy/utils';\n/**\n * This function creates the necessary context objects for a Threlte application.\n */\nexport const createThrelteContext = (options) => {\n    const internalCtx = {\n        frameInvalidated: true,\n        advance: false,\n        autoInvalidations: new Set(),\n        resetFrameInvalidation: () => {\n            internalCtx.frameInvalidated = false;\n            internalCtx.advance = false;\n        },\n        dispose: async (force = false) => {\n            await tick();\n            if (!internalCtx.shouldDispose && !force)\n                return;\n            internalCtx.disposableObjects.forEach((mounted, object) => {\n                if (mounted === 0 || force) {\n                    object?.dispose?.();\n                    internalCtx.disposableObjects.delete(object);\n                }\n            });\n            internalCtx.shouldDispose = false;\n        },\n        collectDisposableObjects: (object, objects) => {\n            const disposables = objects ?? [];\n            if (!object)\n                return disposables;\n            // Scenes can't be disposed\n            if (object?.dispose && typeof object.dispose === 'function' && object.type !== 'Scene') {\n                disposables.push(object);\n            }\n            // iterate over properties of object\n            Object.entries(object).forEach(([propKey, propValue]) => {\n                // we don't want to dispose the parent, we can skip \"children\"\n                if (propKey === 'parent' || propKey === 'children' || typeof propValue !== 'object')\n                    return;\n                const value = propValue;\n                if (value?.dispose) {\n                    internalCtx.collectDisposableObjects(value, disposables);\n                }\n            });\n            return disposables;\n        },\n        addDisposableObjects: (objects) => {\n            objects.forEach((obj) => {\n                const currentValue = internalCtx.disposableObjects.get(obj);\n                if (currentValue) {\n                    internalCtx.disposableObjects.set(obj, currentValue + 1);\n                }\n                else {\n                    internalCtx.disposableObjects.set(obj, 1);\n                }\n            });\n        },\n        removeDisposableObjects: (objects) => {\n            if (objects.length === 0)\n                return;\n            objects.forEach((obj) => {\n                const currentValue = internalCtx.disposableObjects.get(obj);\n                if (currentValue && currentValue > 0) {\n                    internalCtx.disposableObjects.set(obj, currentValue - 1);\n                }\n            });\n            internalCtx.shouldDispose = true;\n        },\n        disposableObjects: new Map(),\n        shouldDispose: false\n    };\n    // TODO: Remove in Threlte 7\n    const { useRenderOrders } = injectLegacyFrameCompatibilityContext();\n    const scheduler = new Scheduler();\n    const mainStage = scheduler.createStage(Symbol('threlte-main-stage'));\n    const renderStage = scheduler.createStage(Symbol('threlte-render-stage'), {\n        after: mainStage,\n        callback(_, runTasks) {\n            if (ctx.shouldRender())\n                runTasks();\n        }\n    });\n    const autoRenderTask = renderStage.createTask(Symbol('threlte-auto-render-task'), (_) => {\n        // we're in here when autoRender is true In Threlte 7 we still have to\n        // check for the existence of `useRender` instances\n        if (useRenderOrders.length > 0)\n            return;\n        // if there are no useRender instances, we can render the scene\n        ctx.renderer.render(ctx.scene, ctx.camera.current);\n    });\n    const ctx = {\n        size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {\n            return uSize ? uSize : pSize;\n        }),\n        camera: currentWritable(getDefaultCamera()),\n        scene: new Scene(),\n        renderer: undefined,\n        invalidate: () => {\n            internalCtx.frameInvalidated = true;\n        },\n        advance: () => {\n            internalCtx.advance = true;\n        },\n        colorSpace: currentWritable(options.colorSpace),\n        toneMapping: currentWritable(options.toneMapping),\n        dpr: currentWritable(options.dpr),\n        useLegacyLights: currentWritable(options.useLegacyLights),\n        shadows: currentWritable(options.shadows),\n        colorManagementEnabled: currentWritable(options.colorManagementEnabled),\n        renderMode: currentWritable(options.renderMode),\n        autoRender: currentWritable(options.autoRender),\n        scheduler,\n        mainStage,\n        renderStage,\n        autoRenderTask,\n        shouldRender: () => {\n            const shouldRender = ctx.renderMode.current === 'always' ||\n                (ctx.renderMode.current === 'on-demand' &&\n                    (internalCtx.frameInvalidated || internalCtx.autoInvalidations.size > 0)) ||\n                (ctx.renderMode.current === 'manual' && internalCtx.advance);\n            return shouldRender;\n        }\n    };\n    setDefaultCameraAspectOnSizeChange(ctx);\n    const userCtx = currentWritable({});\n    setContext('threlte', ctx);\n    setContext('threlte-internal-context', internalCtx);\n    setContext('threlte-user-context', userCtx);\n    return ctx;\n};\n", "export const browser = typeof window !== 'undefined';\n", "import { onDestroy } from 'svelte';\nimport { currentWritable } from '../lib/storeUtils';\nimport { browser } from '../lib/browser';\nexport const useParentSize = () => {\n    const parentSize = currentWritable({ width: 0, height: 0 });\n    if (!browser) {\n        return {\n            parentSize,\n            parentSizeAction: () => {\n                /* do nothing */\n            }\n        };\n    }\n    // Only observe childList changes of the parent\n    const mutationOptions = { childList: true, subtree: false, attributes: false };\n    let el;\n    const observeParent = (parent) => {\n        resizeObserver.disconnect();\n        mutationObserver.disconnect();\n        resizeObserver.observe(parent);\n        mutationObserver.observe(parent, mutationOptions);\n    };\n    // The canvas should match the contentRect of its parent\n    const resizeObserver = new ResizeObserver(([entry]) => {\n        const { width, height } = entry.contentRect;\n        if (width === parentSize.current.width && height === parentSize.current.height)\n            return;\n        parentSize.set({ width, height });\n    });\n    // Use a mutation observer to detect reparenting\n    const mutationObserver = new MutationObserver((mutationsList) => {\n        for (const mutation of mutationsList) {\n            for (const node of mutation.removedNodes) {\n                if (el === node && el.parentElement) {\n                    observeParent(el.parentElement);\n                    return;\n                }\n            }\n        }\n    });\n    const parentSizeAction = (node) => {\n        el = node;\n        const parent = el.parentElement;\n        if (!parent)\n            return;\n        parentSize.set({\n            width: parent.clientWidth,\n            height: parent.clientHeight\n        });\n        observeParent(parent);\n    };\n    onDestroy(() => {\n        resizeObserver.disconnect();\n        mutationObserver.disconnect();\n    });\n    return {\n        parentSize,\n        parentSizeAction\n    };\n};\n", "import { onDestroy } from 'svelte';\nimport { writable } from 'svelte/store';\nexport function createObjectStore(object, onChange) {\n    const objectStore = writable(object);\n    let unwrappedObject = object;\n    const unsubscribeObjectStore = objectStore.subscribe((o) => (unwrappedObject = o));\n    onDestroy(unsubscribeObjectStore);\n    const set = (newObject) => {\n        if (newObject?.uuid === unwrappedObject?.uuid)\n            return;\n        const oldObject = unwrappedObject;\n        objectStore.set(newObject);\n        onChange?.(newObject, oldObject);\n    };\n    const update = (callback) => {\n        const newObject = callback(unwrappedObject);\n        if (newObject?.uuid === unwrappedObject?.uuid)\n            return;\n        const oldObject = unwrappedObject;\n        objectStore.set(newObject);\n        onChange?.(newObject, oldObject);\n    };\n    return {\n        ...objectStore,\n        set,\n        update\n    };\n}\n", "import { getContext } from 'svelte';\nexport const useThrelte = () => {\n    const context = getContext('threlte');\n    if (context === undefined) {\n        throw new Error('No Threlte context found, are you using this hook inside of <Canvas>?');\n    }\n    return context;\n};\n", "import { getContext, setContext } from 'svelte';\nimport { createObjectStore } from '../lib/createObjectStore';\nconst key = Symbol('threlte-hierarchical-parent-context');\nexport const useParent = () => {\n    return getContext(key);\n};\nexport const setParent = (context) => {\n    return setContext(key, context);\n};\nexport const createParentContext = (ref) => {\n    const context = createObjectStore(ref);\n    setContext(key, context);\n    return context;\n};\n", null, null, "/**\n * @file This file contains the cache implementation for Threlte. The cache is\n * used to cache the return value of a promise based on the provided keys.\n */\nimport { getContext, setContext } from 'svelte';\nexport const shallowEqualArrays = (arrA, arrB) => {\n    if (arrA === arrB)\n        return true;\n    if (!arrA || !arrB)\n        return false;\n    const len = arrA.length;\n    if (arrB.length !== len)\n        return false;\n    for (let i = 0; i < len; i++)\n        if (arrA[i] !== arrB[i])\n            return false;\n    return true;\n};\n/**\n * ### `createCache`\n *\n * Every Threlte application has its own cache. This prevents models from being\n * shared between applications because e.g. THREE.Mesh objects cannot be mounted\n * in multiple scenes.\n */\nexport const createCache = () => {\n    setContext('threlte-cache', []);\n};\n/**\n * ### `useCache`\n *\n * This hook is used to access the cache. It returns a `remember` function that\n * can be used to cache a promise based on the provided keys. The `remember`\n * function will return the cached value if the promise has already been\n * resolved and the keys match.\n *\n * @example\n * ```ts\n * const { remember } = useCache()\n *\n * const asnycWritable = remember(async () => {\n *  const loader = new GLTFLoader()\n *  const { scene } = await loader.loadAsync('/path/to/model.glb')\n *  return scene\n * })\n * ```\n *\n * The model will only be loaded once, even if `remember` is invoked multiple\n * times with the same keys.\n *\n * The `clear` function can be used to clear the cache for a specific set of keys.\n */\nexport const useCache = () => {\n    const cache = getContext('threlte-cache');\n    if (!cache) {\n        throw new Error('No cache found. The cache can only be used in a child component to <Canvas>.');\n    }\n    const remember = (callback, keys) => {\n        for (const entry of cache) {\n            // Find a match\n            if (shallowEqualArrays(keys, entry.keys)) {\n                // If an error occurred, throw\n                if (entry.error)\n                    throw entry.error;\n                // If a response is pending, return\n                if (entry.promise)\n                    return entry.promise;\n            }\n        }\n        // If no match was found, create a new entry\n        const entry = {\n            promise: callback(),\n            keys,\n            value: undefined\n        };\n        // Add the entry to the cache\n        cache.push(entry);\n        // Add a catch handler to the promise\n        entry.promise.catch((error) => {\n            // store the error\n            entry.error = error;\n            // we don't throw here\n        });\n        // Return the promise\n        return entry.promise;\n    };\n    const clear = (keys) => {\n        const index = cache.findIndex((entry) => shallowEqualArrays(keys, entry.keys));\n        if (index !== -1) {\n            cache.splice(index, 1);\n        }\n    };\n    return {\n        remember,\n        clear\n    };\n};\n", "import { REVISION } from 'three';\n// REVISION can be '{number}' or '{number}dev'\nconst normalizedRevision = REVISION.replace('dev', '');\n/**\n * The current Three.js revision.\n */\nexport const revision = Number.parseInt(normalizedRevision);\n", "import { writable } from 'svelte/store';\nimport { ColorManagement, PCFSoftShadowMap, WebGLRenderer } from 'three';\nimport { watch } from './storeUtils';\n/**\n * ### `useRenderer`\n *\n * This hook creates a renderer and listens to changes in the context to\n * update the renderer accordingly.\n *\n * It listens to the following context properties:\n * - `colorManagementEnabled`\n * - `colorSpace`\n * - `dpr`\n * - `size`\n * - `shadows`\n * - `toneMapping`\n * - `useLegacyLights`\n */\nexport const useRenderer = (ctx) => {\n    const renderer = writable(undefined);\n    const createRenderer = (canvas, rendererParameters) => {\n        ctx.renderer = new WebGLRenderer({\n            powerPreference: 'high-performance',\n            canvas,\n            antialias: true,\n            alpha: true,\n            ...rendererParameters\n        });\n        renderer.set(ctx.renderer);\n    };\n    watch([ctx.colorManagementEnabled], ([colorManagementEnabled]) => {\n        ColorManagement.enabled = colorManagementEnabled;\n    });\n    watch([renderer, ctx.colorSpace], ([renderer, colorSpace]) => {\n        if (!renderer)\n            return;\n        renderer.outputColorSpace = colorSpace;\n    });\n    watch([renderer, ctx.dpr], ([renderer, dpr]) => {\n        renderer?.setPixelRatio(dpr);\n    });\n    watch([renderer, ctx.size], ([renderer, size]) => {\n        if (renderer?.xr?.isPresenting)\n            return;\n        renderer?.setSize(size.width, size.height);\n    });\n    watch([renderer, ctx.shadows], ([renderer, shadows]) => {\n        if (!renderer)\n            return;\n        renderer.shadowMap.enabled = !!shadows;\n        if (shadows && shadows !== true) {\n            renderer.shadowMap.type = shadows;\n        }\n        else if (shadows === true) {\n            renderer.shadowMap.type = PCFSoftShadowMap;\n        }\n    });\n    watch([renderer, ctx.toneMapping], ([renderer, toneMapping]) => {\n        if (!renderer)\n            return;\n        renderer.toneMapping = toneMapping;\n    });\n    watch([renderer, ctx.useLegacyLights], ([renderer, useLegacyLights]) => {\n        if (!renderer)\n            return;\n        if (useLegacyLights) {\n            renderer.useLegacyLights = useLegacyLights;\n        }\n    });\n    return {\n        createRenderer\n    };\n};\n", "import { getContext } from 'svelte';\nexport const useThrelteInternal = () => {\n    return getContext('threlte-internal-context');\n};\n", null, null, "const classRegex = /^\\s*class\\s+/;\n// Type Guards\nconst isClass = (input) => {\n    if (typeof input !== 'function') {\n        return false;\n    }\n    return classRegex.test(input.toString());\n};\nconst argsIsConstructorParameters = (args) => {\n    return Array.isArray(args);\n};\nexport const determineRef = (is, args) => {\n    if (isClass(is)) {\n        if (argsIsConstructorParameters(args)) {\n            return new is(...args);\n        }\n        else {\n            return new is();\n        }\n    }\n    return is;\n};\nexport const extendsObject3D = (object) => {\n    return 'isObject3D' in object;\n};\nexport const isDisposableObject = (object) => {\n    return 'dispose' in object;\n};\n", "/**\n * ### `resolvePropertyPath`\n *\n * Threlte supports props called \"pierced props\" that allow you to set\n * properties on nested objects. This function resolves a property path to a\n * target object and the property key. The property path can include dots to indicate\n * nested objects.\n *\n * ```svelte\n * <T.PerspectiveCamera position.x={10} />\n * ```\n *\n * … resolves to …\n *\n * ```ts\n * const { target, key } = resolvePropertyPath(camera, 'position.x')\n * target[key] = 10\n * ```\n */\nexport const resolvePropertyPath = (target, propertyPath) => {\n    if (propertyPath.includes('.')) {\n        const path = propertyPath.split('.');\n        const key = path.pop();\n        for (let i = 0; i < path.length; i += 1) {\n            target = target[path[i]];\n        }\n        return {\n            target,\n            key\n        };\n    }\n    else {\n        return {\n            target,\n            key: propertyPath\n        };\n    }\n};\n", "import { onDestroy } from 'svelte';\nimport { useThrelte } from '../../../hooks/useThrelte';\nimport { resolvePropertyPath } from './resolvePropertyPath';\nconst initialValueBeforeAttach = Symbol('initialValueBeforeAttach');\nexport const useAttach = () => {\n    const { invalidate } = useThrelte();\n    let isAttached = false;\n    let valueBeforeAttach = initialValueBeforeAttach;\n    let detachFn;\n    // the target that the object is attached to\n    let attachedTo;\n    // the property name that the object is attached to\n    let attachedKey;\n    const update = (instance, parent, attach) => {\n        detach();\n        // maybe assign 'material' or 'geometry' automatically if not specified\n        if (!attach) {\n            const i = instance;\n            const isMaterial = i?.isMaterial || false;\n            if (isMaterial) {\n                attach = 'material';\n            }\n            const isGeometry = i?.isBufferGeometry || i?.isGeometry || false;\n            if (isGeometry) {\n                attach = 'geometry';\n            }\n        }\n        if (!attach)\n            return;\n        if (typeof attach === 'function') {\n            detachFn = attach(parent, instance);\n        }\n        else {\n            const { target, key } = resolvePropertyPath(parent, attach);\n            valueBeforeAttach = target[key];\n            target[key] = instance;\n            attachedTo = target;\n            attachedKey = key;\n        }\n        isAttached = true;\n        invalidate();\n    };\n    const detach = () => {\n        if (!isAttached)\n            return;\n        if (detachFn) {\n            detachFn();\n            detachFn = undefined;\n        }\n        else if (attachedTo && attachedKey && valueBeforeAttach !== initialValueBeforeAttach) {\n            attachedTo[attachedKey] = valueBeforeAttach;\n            valueBeforeAttach = initialValueBeforeAttach;\n            attachedTo = undefined;\n            attachedKey = undefined;\n        }\n        isAttached = false;\n        invalidate();\n    };\n    onDestroy(() => {\n        detach();\n    });\n    return {\n        update\n    };\n};\n", "import { onDestroy } from 'svelte';\nimport { useThrelte } from '../../../hooks/useThrelte';\nconst isCamera = (value) => {\n    return value && value.isCamera;\n};\nconst isOrthographicCamera = (value) => {\n    return value && value.isOrthographicCamera;\n};\nconst isPerspectiveCamera = (value) => {\n    return value && value.isPerspectiveCamera;\n};\nconst isPerspectiveCameraOrOrthographicCamera = (value) => {\n    return isPerspectiveCamera(value) || isOrthographicCamera(value);\n};\nexport const useCamera = () => {\n    const { invalidate, size, camera } = useThrelte();\n    let currentInstance;\n    let unsubscribe = undefined;\n    onDestroy(() => {\n        unsubscribe?.();\n    });\n    const subscriber = (size) => {\n        if (!currentInstance)\n            return;\n        if (isOrthographicCamera(currentInstance)) {\n            currentInstance.left = size.width / -2;\n            currentInstance.right = size.width / 2;\n            currentInstance.top = size.height / 2;\n            currentInstance.bottom = size.height / -2;\n            currentInstance.updateProjectionMatrix();\n            currentInstance.updateMatrixWorld();\n            invalidate();\n        }\n        else if (isPerspectiveCamera(currentInstance)) {\n            currentInstance.aspect = size.width / size.height;\n            currentInstance.updateProjectionMatrix();\n            currentInstance.updateMatrixWorld();\n            invalidate();\n        }\n    };\n    const update = (instance, manual) => {\n        unsubscribe?.();\n        if (manual || !isPerspectiveCameraOrOrthographicCamera(instance)) {\n            currentInstance = undefined;\n            return;\n        }\n        currentInstance = instance;\n        unsubscribe = size.subscribe(subscriber);\n    };\n    const makeDefaultCamera = (instance, makeDefault) => {\n        if (!isCamera(instance) || !makeDefault)\n            return;\n        camera.set(instance);\n        invalidate();\n    };\n    return {\n        update,\n        makeDefaultCamera\n    };\n};\n", "import { get_current_component } from 'svelte/internal';\n/**\n * ### `createRawEventDispatcher`\n *\n * This event dispatcher creates raw events unlike Svelte's own event dispatcher\n * which nests the data in a detail object (`CustomEvent<Payload>`). This is not\n * nesessary for a lot of Threlte use cases and makes it harder to work with the payload.\n *\n * @example\n *\n * ComponentA.svelte:\n * ```svelte\n * <script>\n * \tconst dispatch = createRawEventDispatcher<{ foo: string }>()\n * \tdispatch('foo', 'bar')\n * </script>\n * ```\n *\n * ComponentB.svelte:\n * ```svelte\n * <ComponentA on:foo={(e) => console.log(e)} /> <!-- 'bar' -->\n * ```\n */\nexport const createRawEventDispatcher = () => {\n    const component = get_current_component();\n    const dispatchRawEvent = (type, value) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            callbacks.forEach((fn) => {\n                fn(value);\n            });\n        }\n    };\n    const hasEventListener = (type) => {\n        return Boolean(component.$$.callbacks[type]);\n    };\n    Object.defineProperty(dispatchRawEvent, 'hasEventListener', {\n        value: hasEventListener,\n        enumerable: true\n    });\n    return dispatchRawEvent;\n};\n", "import { onDestroy, onMount } from 'svelte';\nimport { createRawEventDispatcher } from '../../../lib/createRawEventDispatcher';\nexport const useCreateEvent = () => {\n    const dispatchRaw = createRawEventDispatcher();\n    const cleanupFunctions = [];\n    let ref = undefined;\n    let mounted = false;\n    const dispatchCreateEvent = () => {\n        // call every cleanup function\n        cleanupFunctions.forEach((cleanup) => cleanup());\n        // clear the cleanup functions array\n        cleanupFunctions.length = 0;\n        const cleanup = (callback) => {\n            // add cleanup function to array\n            cleanupFunctions.push(callback);\n        };\n        dispatchRaw('create', { ref, cleanup });\n    };\n    const updateRef = (newRef) => {\n        ref = newRef;\n        if (!mounted)\n            return;\n        dispatchCreateEvent();\n    };\n    onMount(() => {\n        dispatchCreateEvent();\n        mounted = true;\n    });\n    onDestroy(() => {\n        // call every cleanup function\n        cleanupFunctions.forEach((cleanup) => cleanup());\n    });\n    return {\n        updateRef\n    };\n};\n", "import { onMount } from 'svelte';\nimport { get_current_component } from 'svelte/internal';\nimport { writable } from 'svelte/store';\nimport { createRawEventDispatcher } from '../../../lib/createRawEventDispatcher';\nimport { watch } from '../../../lib/storeUtils';\n/**\n * Typeguard to check if a value is extending THREE.EventDispatcher\n * @param value\n * @returns\n */\nconst isEventDispatcher = (value) => {\n    return !!value?.addEventListener;\n};\nexport const useEvents = () => {\n    const dispatch = createRawEventDispatcher();\n    const component = get_current_component();\n    const eventHandlerProxy = (event) => {\n        if (event?.type) {\n            dispatch(event.type, event);\n        }\n    };\n    const cleanupEventListeners = (ref, events) => {\n        if (isEventDispatcher(ref)) {\n            events.forEach((eventName) => {\n                ref.removeEventListener(eventName, eventHandlerProxy);\n            });\n        }\n    };\n    const addEventListeners = (ref, events) => {\n        if (isEventDispatcher(ref)) {\n            events.forEach((eventName) => {\n                ref.addEventListener(eventName, eventHandlerProxy);\n            });\n        }\n    };\n    const ref = writable();\n    const eventNames = writable([]);\n    watch([ref, eventNames], ([$ref, $eventNames]) => {\n        addEventListeners($ref, $eventNames);\n        return () => cleanupEventListeners($ref, $eventNames);\n    });\n    // get all event callbacks from component\n    onMount(() => {\n        eventNames.set(Object.keys(component.$$.callbacks));\n    });\n    const updateRef = (newRef) => {\n        ref.set(newRef);\n    };\n    return {\n        updateRef\n    };\n};\n", "import { getContext, onDestroy } from 'svelte';\nexport const usePlugins = (params) => {\n    const pluginContextName = 'threlte-plugin-context';\n    const plugins = getContext(pluginContextName);\n    if (!plugins)\n        return;\n    const pluginsReturns = Object.values(plugins)\n        .map((plugin) => plugin(params))\n        .filter(Boolean);\n    const pluginsProps = pluginsReturns.flatMap((callback) => callback.pluginProps ?? []);\n    let refCleanupCallbacks = [];\n    onDestroy(() => {\n        refCleanupCallbacks.forEach((callback) => callback());\n    });\n    const updateRef = (ref) => {\n        refCleanupCallbacks.forEach((callback) => callback());\n        refCleanupCallbacks = [];\n        pluginsReturns.forEach((callback) => {\n            const cleanupCallback = callback.onRefChange?.(ref);\n            if (cleanupCallback) {\n                refCleanupCallbacks.push(cleanupCallback);\n            }\n        });\n    };\n    const updateProps = (props) => {\n        pluginsReturns.forEach((callback) => {\n            callback.onPropsChange?.(props);\n        });\n    };\n    const updateRestProps = (restProps) => {\n        pluginsReturns.forEach((callback) => {\n            callback.onRestPropsChange?.(restProps);\n        });\n    };\n    return {\n        updateRef,\n        updateProps,\n        updateRestProps,\n        pluginsProps\n    };\n};\n", "import { useThrelte } from '../../../hooks/useThrelte';\nimport { resolvePropertyPath } from './resolvePropertyPath';\nconst ignoredProps = new Set(['$$scope', '$$slots', 'type', 'args', 'attach', 'instance']);\nconst updateProjectionMatrixKeys = new Set([\n    'fov',\n    'aspect',\n    'near',\n    'far',\n    'left',\n    'right',\n    'top',\n    'bottom',\n    'zoom'\n]);\n/**\n * Only scalar values are memoized, objects and arrays are considered\n * non-equa by default, to ensure reactivity works as you would\n * expect in svelte.\n * @param value\n * @returns\n */\nexport const memoizeProp = (value) => {\n    // scalar values are memoized\n    if (typeof value === 'string')\n        return true;\n    if (typeof value === 'number')\n        return true;\n    if (typeof value === 'boolean')\n        return true;\n    if (typeof value === 'undefined')\n        return true;\n    if (value === null)\n        return true;\n    // objects and arrays cannot be reliably memoized\n    return false;\n};\nconst createSetter = (target, key, value) => {\n    if (!Array.isArray(value) &&\n        typeof value === 'number' &&\n        typeof target[key]?.setScalar === 'function' &&\n        // colors do have a setScalar function, but we don't want to use it, because\n        // the hex notation (i.e. 0xff0000) is very popular and matches the number\n        // type. So we exclude colors here.\n        !target[key]?.isColor) {\n        // edge case of setScalar setters\n        return (target, key, value) => {\n            target[key].setScalar(value);\n        };\n    }\n    else {\n        if (typeof target[key]?.set === 'function') {\n            // if the property has a \"set\" function, we can use it\n            if (Array.isArray(value)) {\n                return (target, key, value) => {\n                    target[key].set(...value);\n                };\n            }\n            else {\n                return (target, key, value) => {\n                    target[key].set(value);\n                };\n            }\n        }\n        else {\n            // otherwise, we just set the value\n            return (target, key, value) => {\n                target[key] = value;\n            };\n        }\n    }\n};\nexport const useProps = () => {\n    const { invalidate } = useThrelte();\n    const memoizedProps = new Map();\n    const memoizedSetters = new Map();\n    const setProp = (instance, propertyPath, value, options) => {\n        if (memoizeProp(value)) {\n            const memoizedProp = memoizedProps.get(propertyPath);\n            if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {\n                return;\n            }\n            memoizedProps.set(propertyPath, {\n                instance,\n                value\n            });\n        }\n        const { key, target } = resolvePropertyPath(instance, propertyPath);\n        if (value !== undefined && value !== null) {\n            const memoizedSetter = memoizedSetters.get(propertyPath);\n            if (memoizedSetter) {\n                memoizedSetter(target, key, value);\n            }\n            else {\n                const setter = createSetter(target, key, value);\n                memoizedSetters.set(propertyPath, setter);\n                setter(target, key, value);\n            }\n        }\n        else {\n            createSetter(target, key, value)(target, key, value);\n        }\n        if (options.manualCamera)\n            return;\n        if (updateProjectionMatrixKeys.has(key) &&\n            (target.isPerspectiveCamera || target.isOrthographicCamera)) {\n            target.updateProjectionMatrix();\n        }\n    };\n    const updateProps = (instance, props, options) => {\n        for (const key in props) {\n            if (!ignoredProps.has(key) && !options.pluginsProps?.includes(key)) {\n                setProp(instance, key, props[key], options);\n            }\n            invalidate();\n        }\n    };\n    return {\n        updateProps\n    };\n};\n", null, "import * as THREE from 'three';\nimport TComp from './T.svelte';\nconst catalogue = {};\n/**\n * Extends the default THREE namespace and allows using custom Three.js objects with `<T>`.\n *\n * @example\n * ```svelte\n * <script>\n * \timport { extend, T } from 'threlte'\n * \timport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n *\n * \textend({ OrbitControls })\n * </script>\n *\n * <T.OrbitControls />\n * ```\n */\nexport const extend = (extensions) => {\n    Object.assign(catalogue, extensions);\n};\nconst augmentConstructorArgs = (args, is) => {\n    const module = catalogue[is] || THREE[is];\n    if (!module) {\n        throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);\n    }\n    return {\n        ...args,\n        props: {\n            ...args.props,\n            is: module\n        }\n    };\n};\nconst proxyTConstructor = (is) => {\n    return new Proxy(class {\n    }, {\n        construct(_, [args]) {\n            const castedArgs = args;\n            return new TComp(augmentConstructorArgs(castedArgs, is));\n        }\n    });\n};\n/**\n * ## `<T>`\n *\n * Threlte's `<T>` component is a wrapper around Three.js objects. It is a generic component that can be used to create any Three.js object.\n *\n * @example\n *\n * ```svelte\n * <script>\n * \timport { T } from 'threlte'\n * </script>\n *\n * <T.PerspectiveCamera makeDefault />\n *\n * <T.Mesh>\n * \t<T.BoxGeometry />\n * \t<T.MeshBasicMaterial color=\"red\" />\n * </T.Mesh>\n * ```\n */\nexport const T = new Proxy(class {\n}, {\n    construct(_, [args]) {\n        const castedArgs = args;\n        return new TComp(castedArgs);\n    },\n    get(_, is) {\n        return proxyTConstructor(is);\n    }\n});\n", "import { getContext, setContext } from 'svelte';\nexport function injectPlugin(nameOrNamedPlugin, maybePlugin) {\n    const contextName = 'threlte-plugin-context';\n    if (Array.isArray(nameOrNamedPlugin)) {\n        const [name, plugin] = nameOrNamedPlugin;\n        setContext(contextName, {\n            ...getContext(contextName),\n            [name]: plugin\n        });\n    }\n    else {\n        const name = nameOrNamedPlugin;\n        const plugin = maybePlugin;\n        if (!plugin)\n            return;\n        setContext(contextName, {\n            ...getContext(contextName),\n            [name]: plugin\n        });\n    }\n}\n", "export function createPlugin(name, plugin) {\n    return [name, plugin];\n}\n", "import { getContext, onDestroy } from 'svelte';\nimport { readable, writable } from 'svelte/store';\nimport { DAG } from '../frame-scheduling';\nimport { browser } from '../lib/browser';\nimport { useThrelte } from './useThrelte';\nexport function useTask(keyOrFn, fnOrOptions, options) {\n    if (!browser) {\n        return {\n            task: undefined,\n            start: () => undefined,\n            stop: () => undefined,\n            started: readable(false)\n        };\n    }\n    let key;\n    let fn;\n    let opts;\n    if (DAG.isKey(keyOrFn)) {\n        key = keyOrFn;\n        fn = fnOrOptions;\n        opts = options;\n    }\n    else {\n        key = Symbol('useTask');\n        fn = keyOrFn;\n        opts = fnOrOptions;\n    }\n    const ctx = useThrelte();\n    let stage = ctx.mainStage;\n    if (opts) {\n        if (opts.stage) {\n            if (DAG.isValue(opts.stage)) {\n                stage = opts.stage;\n            }\n            else {\n                const maybeStage = ctx.scheduler.getStage(opts.stage);\n                if (!maybeStage) {\n                    throw new Error(`No stage found with key ${opts.stage.toString()}`);\n                }\n                stage = maybeStage;\n            }\n        }\n        else if (opts.after) {\n            if (Array.isArray(opts.after)) {\n                for (let index = 0; index < opts.after.length; index++) {\n                    const element = opts.after[index];\n                    if (DAG.isValue(element)) {\n                        stage = element.stage;\n                        break;\n                    }\n                }\n            }\n            else if (DAG.isValue(opts.after)) {\n                stage = opts.after.stage;\n            }\n        }\n        else if (opts.before) {\n            if (Array.isArray(opts.before)) {\n                for (let index = 0; index < opts.before.length; index++) {\n                    const element = opts.before[index];\n                    if (DAG.isValue(element)) {\n                        stage = element.stage;\n                        break;\n                    }\n                }\n            }\n            else if (DAG.isValue(opts.before)) {\n                stage = opts.before.stage;\n            }\n        }\n    }\n    const { autoInvalidations } = getContext('threlte-internal-context');\n    const started = writable(false);\n    const task = stage.createTask(key, fn, opts);\n    const start = () => {\n        started.set(true);\n        if (opts?.autoInvalidate ?? true) {\n            autoInvalidations.add(fn);\n        }\n        task.start();\n    };\n    const stop = () => {\n        started.set(true);\n        if (opts?.autoInvalidate ?? true) {\n            autoInvalidations.delete(fn);\n        }\n        task.stop();\n    };\n    if (opts?.autoStart ?? true) {\n        start();\n    }\n    else {\n        stop();\n    }\n    onDestroy(() => {\n        if (!stage)\n            return;\n        stage.removeTask(key);\n    });\n    return {\n        task,\n        start,\n        stop,\n        started: {\n            subscribe: started.subscribe\n        }\n    };\n}\n", "import { useThrelte } from './useThrelte';\n/**\n * Creates a stage and returns it. If the stage already exists, it is returned.\n *\n * @param key The key of the stage.\n * @param options Options for creating the stage.\n */\nexport function useStage(key, options) {\n    const { scheduler } = useThrelte();\n    return scheduler.getStage(key) ?? scheduler.createStage(key, options);\n}\n", "import { getContext } from 'svelte';\nimport { derived } from 'svelte/store';\nexport function useThrelteUserContext(namespace, value, options) {\n    const userCtxStore = getContext('threlte-user-context');\n    if (!userCtxStore) {\n        throw new Error('No user context store found, did you invoke this function outside of your main <Canvas> component?');\n    }\n    // return the plain user context store\n    if (!namespace) {\n        return {\n            subscribe: userCtxStore.subscribe\n        };\n    }\n    // return a specific user context entry\n    if (namespace && !value) {\n        return derived(userCtxStore, (ctx) => ctx[namespace]);\n    }\n    // we are possibly setting a new user context entry here\n    userCtxStore.update((ctx) => {\n        if (namespace in ctx) {\n            // skip is the default value\n            if (!options || options.existing === 'skip')\n                return ctx;\n            if (options.existing === 'merge') {\n                Object.assign(ctx[namespace], value);\n                return ctx;\n            }\n        }\n        // also handles options.existing === 'replace'\n        ctx[namespace] = value;\n        return ctx;\n    });\n    return userCtxStore.current[namespace];\n}\n", "import { getContext, onDestroy } from 'svelte';\nimport { readable, writable } from 'svelte/store';\nimport { browser } from '../../lib/browser';\nimport { useLegacyFrameCompatibilityContext } from './utils';\nimport { useThrelte } from '../useThrelte';\nconst orderToKey = (order) => `useFrame-order-${order.toString()}`;\n/**\n * Adds a handler to threltes unified render loop.\n *\n * `start` and `stop` functions are returned and the options allow\n * setting the handler to not start automatically.\n *\n * Provide an order to have your framehandlers running in a specific order.\n * Handlers are ordered from low to high when executing.\n * @param {(ctx: ThrelteContext, delta: number) => void} fn callback function\n * @param {ThrelteUseFrameOptions} options options\n * @returns {ThrelteUseFrame}\n */\nexport const useFrame = (fn, options) => {\n    if (!browser) {\n        return {\n            start: () => undefined,\n            stop: () => undefined,\n            started: readable(false)\n        };\n    }\n    const started = writable(false);\n    const ctx = useThrelte();\n    const { useFrameOrders } = useLegacyFrameCompatibilityContext();\n    const { autoInvalidations } = getContext('threlte-internal-context');\n    let order = options?.order ?? 0;\n    while (useFrameOrders.includes(order)) {\n        order += 0.01;\n    }\n    useFrameOrders.push(order);\n    const key = orderToKey(order);\n    const proxy = (delta) => {\n        fn(ctx, delta);\n    };\n    const task = ctx.mainStage.createTask(key, proxy, {\n        after: useFrameOrders.filter((o) => o < order).map((o) => orderToKey(o)),\n        before: useFrameOrders.filter((o) => o > order).map((o) => orderToKey(o))\n    });\n    const start = () => {\n        started.set(true);\n        if (options?.invalidate ?? true) {\n            autoInvalidations.add(fn);\n        }\n        task.start();\n    };\n    const stop = () => {\n        started.set(true);\n        if (options?.invalidate ?? true) {\n            autoInvalidations.delete(fn);\n        }\n        task.stop();\n    };\n    if (options?.autostart ?? true) {\n        start();\n    }\n    else {\n        stop();\n    }\n    onDestroy(() => {\n        ctx.mainStage.removeTask(key);\n        useFrameOrders.splice(useFrameOrders.indexOf(order), 1);\n    });\n    return {\n        start,\n        stop,\n        started: {\n            subscribe: started.subscribe\n        }\n    };\n};\n", "import { onDestroy } from 'svelte';\nimport { browser } from '../../lib/browser';\nimport { orderToKey, useLegacyFrameCompatibilityContext } from './utils';\nimport { useThrelte } from '../useThrelte';\n/**\n * Adds a handler that is called on every invalidated frame. This handler is\n * only called when an actual render should happen.\n * @param fn\n * @param options\n * @returns\n */\nexport const useRender = (fn, options) => {\n    if (!browser) {\n        return;\n    }\n    const ctx = useThrelte();\n    const { useRenderOrders } = useLegacyFrameCompatibilityContext();\n    let order = options?.order ?? 0;\n    while (useRenderOrders.includes(order)) {\n        order += 0.01;\n    }\n    useRenderOrders.push(order);\n    const key = orderToKey(order);\n    const proxy = (delta) => {\n        fn(ctx, delta);\n    };\n    ctx.renderStage.createTask(key, proxy, {\n        after: useRenderOrders.filter((o) => o < order).map((o) => orderToKey(o)),\n        before: useRenderOrders.filter((o) => o > order).map((o) => orderToKey(o))\n    });\n    onDestroy(() => {\n        ctx.renderStage.removeTask(key);\n        useRenderOrders.splice(useRenderOrders.indexOf(order), 1);\n    });\n};\n", "import { writable } from 'svelte/store';\n/**\n * ### `asyncWritable`\n *\n * Creates a writable store that is initialized with a promise. The store also\n * implements the `then` and `catch` methods of the promise so that it can be\n * used in `await` expressions and `{#await}` blocks of Svelte.\n *\n * ```svelte\n * <script>\n *  import { asyncWritable } from '@threlte/core'\n *\n *  const asyncOp = async () => {\n *    // Do something async\n *  }\n *\n *  const store = asyncWritable(asyncOp())\n *  $: console.log($store) // asyncOp result\n * </script>\n *\n * <h1>\n *  {#await store then data}\n *    // Do something with the data\n *  {/await}\n * </h1>\n * ```\n *\n * If an error occurs in the promise, the error will be logged to the console\n * and the error can be accessed via the `error` property of the store with in\n * turn is a store.\n *\n * ```svelte\n * <script>\n *  import { asyncWritable } from '@threlte/core'\n *\n *  const asyncOp = async () => {\n *    throw new Error('Something went wrong')\n *  }\n *\n *  const store = asyncWritable(asyncOp())\n *  const error = store.error\n *\n *  $: console.log($store) // undefined\n *  $: console.log($error) // Error: Something went wrong\n * </script>\n * ```\n */\nexport const asyncWritable = (promise) => {\n    const store = writable(undefined);\n    const error = writable(undefined);\n    promise\n        .then((result) => {\n        store.set(result);\n    })\n        .catch((e) => {\n        console.error('Error in asyncWritable:', e.message);\n        error.set(e);\n    });\n    return Object.assign(Object.assign(promise, store), { error, promise });\n};\n", "import { asyncWritable } from '../lib/asyncWritable';\nimport { useCache } from '../lib/cache';\nexport function useLoader(Proto, options) {\n    const { remember, clear: clearCacheItem } = useCache();\n    let loader;\n    const initializeLoader = () => {\n        // Type-wrestling galore\n        const lazyLoader = new Proto(...(options?.args ?? []));\n        // extend the loader if necessary\n        options?.extend?.(lazyLoader);\n        return lazyLoader;\n    };\n    const load = (input, options) => {\n        // Allow Async and Sync loaders\n        const loadResource = async (url) => {\n            if (!loader) {\n                loader = initializeLoader();\n            }\n            if ('loadAsync' in loader) {\n                const result = await loader.loadAsync(url, options?.onProgress);\n                return options?.transform?.(result) ?? result;\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    ;\n                    loader.load(url, (data) => resolve(options?.transform?.(data) ?? data), (event) => options?.onProgress?.(event), reject);\n                });\n            }\n        };\n        if (Array.isArray(input)) {\n            // map over the input array and return an array of promises\n            const promises = input.map((url) => {\n                return remember(() => loadResource(url), [Proto, url]);\n            });\n            // return an AsyncWritable that resolves to the array of promises\n            const store = asyncWritable(Promise.all(promises));\n            return store; // TODO: Dirty escape hatch\n        }\n        else if (typeof input === 'string') {\n            const promise = remember(() => loadResource(input), [Proto, input]);\n            // return an AsyncWritable that resolves to the promise\n            const store = asyncWritable(promise);\n            return store; // TODO: Dirty escape hatch\n        }\n        else {\n            // map over the input object and return an array of promises\n            const promises = Object.values(input).map((url) => {\n                return remember(() => loadResource(url), [Proto, url]);\n            });\n            // return an AsyncWritable that resolves to the object of promises\n            const store = asyncWritable(Promise.all(promises).then((results) => {\n                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));\n            }));\n            return store; // TODO: Dirty escape hatch\n        }\n    };\n    const clear = (input) => {\n        if (Array.isArray(input)) {\n            input.forEach((url) => {\n                clearCacheItem([Proto, url]);\n            });\n        }\n        else if (typeof input === 'string') {\n            clearCacheItem([Proto, input]);\n        }\n        else {\n            Object.entries(input).forEach(([key, url]) => {\n                clearCacheItem([Proto, key, url]);\n            });\n        }\n    };\n    return {\n        load,\n        clear,\n        loader\n    };\n}\n// Type tests\n// class WithConstructorParameters {\n//   constructor(hello: 'abc' | 'def') {\n//     console.log(hello)\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// class WithOptionalConstructorParameters {\n//   constructor(hello?: string) {\n//     console.log(hello)\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// class WithoutConstructorParameters {\n//   constructor() {\n//     console.log('without')\n//   }\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\n//     return new Promise((r) => r('hello'))\n//   }\n// }\n// const shouldFail = () => {\n//   useLoader(WithConstructorParameters)\n//   useLoader(WithoutConstructorParameters, {\n//     args: ['hello']\n//   })\n// }\n// const shouldSucceed = () => {\n//   useLoader(WithConstructorParameters, {\n//     args: ['abc']\n//   })\n//   useLoader(WithConstructorParameters, {\n//     args: ['abc'],\n//     extend(loader) {\n//       // …\n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters)\n//   useLoader(WithOptionalConstructorParameters, {\n//     extend(loader) {\n//       // …\n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: [],\n//     extend(loader) {\n//       // …\n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: ['hello'],\n//     extend(loader) {\n//       // …\n//     }\n//   })\n//   useLoader(WithOptionalConstructorParameters, {\n//     args: ['hello']\n//   })\n//   useLoader(WithoutConstructorParameters)\n//   useLoader(WithoutConstructorParameters, {\n//     extend(loader) {\n//       // …\n//     }\n//   })\n// }\n", "import { get_current_component } from 'svelte/internal';\nimport { writable } from 'svelte/store';\nimport { watch } from './storeUtils';\n/**\n * ### `forwardEventHandlers`\n *\n * Natively, Svelte has no way of passing down event handlers inside a\n * component to a child component. Events have to be hand-wired upstream. This\n * function allows you to forward event handlers from a parent component to a child\n * component as if they were declared on the child component itself.\n *\n * ```svelte\n * <!-- Child.svelte -->\n * <script>\n * \timport { forwardEventHandlers } from '@threlte/core'\n * \tconst dispatchingComponent = forwardEventHandlers()\n * </script>\n *\n * <OtherChildComponent bind:this={$dispatchingComponent} />\n * ```\n *\n * Now, when implementing `<Child>` and adding event handlers via `on:eventname`,\n * those event handlers will be forwarded to `<OtherChildComponent>`:\n *\n * ```svelte\n * <!-- Parent.svelte -->\n * <script>\n * \timport Child from './Child.svelte'\n * </script>\n *\n * <Child on:click={() => console.log('clicked')} />\n * ```\n *\n * If `OtherChildComponent.svelte` now dispatches a `click` event, the event handler\n * in `Parent.svelte` will be called.\n */\nexport const forwardEventHandlers = () => {\n    const component = get_current_component();\n    const dispatchingComponent = writable(undefined);\n    watch(dispatchingComponent, (dispatchingComponent) => {\n        if (!dispatchingComponent)\n            return;\n        Object.entries(component.$$.callbacks).forEach((callback) => {\n            const [key, value] = callback;\n            if (key in dispatchingComponent.$$.callbacks &&\n                Array.isArray(dispatchingComponent.$$.callbacks[key])) {\n                dispatchingComponent.$$.callbacks[key].push(...value);\n            }\n            else {\n                dispatchingComponent.$$.callbacks[key] = value;\n            }\n        });\n    });\n    return dispatchingComponent;\n};\n"],
  "mappings": "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",
  "names": ["all", "Map", "on", "type", "handler", "handlers", "get", "push", "set", "off", "splice", "indexOf", "emit", "evt", "slice", "map", "key", "key", "key", "key", "start", "value", "_a", "entry", "renderer", "ctx", "initialized", "autoRender", "key", "instance", "key", "size", "instance", "cleanup", "ref", "key", "target", "value", "instance", "ctx", "T", "contextName", "key", "element", "key", "orderToKey", "key", "key", "options", "_a", "key", "dispatchingComponent", "key"]
}
