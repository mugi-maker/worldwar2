import { setContext, tick } from 'svelte';
import { derived } from 'svelte/store';
import { Scene } from 'three';
import { Scheduler } from '../frame-scheduling';
import { getDefaultCamera, setDefaultCameraAspectOnSizeChange } from './defaultCamera';
import { currentWritable } from './storeUtils';
import { injectLegacyFrameCompatibilityContext } from '../hooks/legacy/utils';
/**
 * This function creates the necessary context objects for a Threlte application.
 */
export const createThrelteContext = (options) => {
    const internalCtx = {
        frameInvalidated: true,
        advance: false,
        autoInvalidations: new Set(),
        resetFrameInvalidation: () => {
            internalCtx.frameInvalidated = false;
            internalCtx.advance = false;
        },
        dispose: async (force = false) => {
            await tick();
            if (!internalCtx.shouldDispose && !force)
                return;
            internalCtx.disposableObjects.forEach((mounted, object) => {
                if (mounted === 0 || force) {
                    object?.dispose?.();
                    internalCtx.disposableObjects.delete(object);
                }
            });
            internalCtx.shouldDispose = false;
        },
        collectDisposableObjects: (object, objects) => {
            const disposables = objects ?? [];
            if (!object)
                return disposables;
            // Scenes can't be disposed
            if (object?.dispose && typeof object.dispose === 'function' && object.type !== 'Scene') {
                disposables.push(object);
            }
            // iterate over properties of object
            Object.entries(object).forEach(([propKey, propValue]) => {
                // we don't want to dispose the parent, we can skip "children"
                if (propKey === 'parent' || propKey === 'children' || typeof propValue !== 'object')
                    return;
                const value = propValue;
                if (value?.dispose) {
                    internalCtx.collectDisposableObjects(value, disposables);
                }
            });
            return disposables;
        },
        addDisposableObjects: (objects) => {
            objects.forEach((obj) => {
                const currentValue = internalCtx.disposableObjects.get(obj);
                if (currentValue) {
                    internalCtx.disposableObjects.set(obj, currentValue + 1);
                }
                else {
                    internalCtx.disposableObjects.set(obj, 1);
                }
            });
        },
        removeDisposableObjects: (objects) => {
            if (objects.length === 0)
                return;
            objects.forEach((obj) => {
                const currentValue = internalCtx.disposableObjects.get(obj);
                if (currentValue && currentValue > 0) {
                    internalCtx.disposableObjects.set(obj, currentValue - 1);
                }
            });
            internalCtx.shouldDispose = true;
        },
        disposableObjects: new Map(),
        shouldDispose: false
    };
    // TODO: Remove in Threlte 7
    const { useRenderOrders } = injectLegacyFrameCompatibilityContext();
    const scheduler = new Scheduler();
    const mainStage = scheduler.createStage(Symbol('threlte-main-stage'));
    const renderStage = scheduler.createStage(Symbol('threlte-render-stage'), {
        after: mainStage,
        callback(_, runTasks) {
            if (ctx.shouldRender())
                runTasks();
        }
    });
    const autoRenderTask = renderStage.createTask(Symbol('threlte-auto-render-task'), (_) => {
        // we're in here when autoRender is true In Threlte 7 we still have to
        // check for the existence of `useRender` instances
        if (useRenderOrders.length > 0)
            return;
        // if there are no useRender instances, we can render the scene
        ctx.renderer.render(ctx.scene, ctx.camera.current);
    });
    const ctx = {
        size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {
            return uSize ? uSize : pSize;
        }),
        camera: currentWritable(getDefaultCamera()),
        scene: new Scene(),
        renderer: undefined,
        invalidate: () => {
            internalCtx.frameInvalidated = true;
        },
        advance: () => {
            internalCtx.advance = true;
        },
        colorSpace: currentWritable(options.colorSpace),
        toneMapping: currentWritable(options.toneMapping),
        dpr: currentWritable(options.dpr),
        useLegacyLights: currentWritable(options.useLegacyLights),
        shadows: currentWritable(options.shadows),
        colorManagementEnabled: currentWritable(options.colorManagementEnabled),
        renderMode: currentWritable(options.renderMode),
        autoRender: currentWritable(options.autoRender),
        scheduler,
        mainStage,
        renderStage,
        autoRenderTask,
        shouldRender: () => {
            const shouldRender = ctx.renderMode.current === 'always' ||
                (ctx.renderMode.current === 'on-demand' &&
                    (internalCtx.frameInvalidated || internalCtx.autoInvalidations.size > 0)) ||
                (ctx.renderMode.current === 'manual' && internalCtx.advance);
            return shouldRender;
        }
    };
    setDefaultCameraAspectOnSizeChange(ctx);
    const userCtx = currentWritable({});
    setContext('threlte', ctx);
    setContext('threlte-internal-context', internalCtx);
    setContext('threlte-user-context', userCtx);
    return ctx;
};
