import {
  ACESFilmicToneMapping,
  ColorManagement,
  PCFSoftShadowMap,
  PerspectiveCamera,
  REVISION,
  Scene,
  WebGLRenderer,
  three_module_exports
} from "./chunk-GMFGCRRE.js";
import {
  derived,
  readable,
  writable
} from "./chunk-KDKHRZOR.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  group_outros,
  init,
  insert_dev,
  mount_component,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  space,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-3NDD2IKE.js";
import {
  __publicField
} from "./chunk-DC5AMYBS.js";

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// node_modules/@threlte/core/dist/frame-scheduling/DAG.js
var DAG = class {
  constructor() {
    __publicField(this, "allVertices", {});
    /** Nodes that are fully unlinked */
    __publicField(this, "isolatedVertices", {});
    __publicField(this, "connectedVertices", {});
    __publicField(this, "sortedConnectedValues", []);
    __publicField(this, "needsSort", false);
    __publicField(this, "emitter", mitt_default());
    __publicField(this, "emit", this.emitter.emit.bind(this.emitter));
    __publicField(this, "on", this.emitter.on.bind(this.emitter));
    __publicField(this, "off", this.emitter.off.bind(this.emitter));
    __publicField(this, "getKey", (v) => {
      if (typeof v === "object") {
        return v.key;
      }
      return v;
    });
  }
  get sortedVertices() {
    return this.mapNodes((value) => value);
  }
  moveToIsolated(key2) {
    const vertex = this.connectedVertices[key2];
    if (!vertex)
      return;
    this.isolatedVertices[key2] = vertex;
    delete this.connectedVertices[key2];
  }
  moveToConnected(key2) {
    const vertex = this.isolatedVertices[key2];
    if (!vertex)
      return;
    this.connectedVertices[key2] = vertex;
    delete this.isolatedVertices[key2];
  }
  add(key2, value, options) {
    if (this.allVertices[key2] && this.allVertices[key2].value !== void 0) {
      throw new Error(`A node with the key ${key2.toString()} already exists`);
    }
    let vertex = this.allVertices[key2];
    if (!vertex) {
      vertex = {
        value,
        previous: /* @__PURE__ */ new Set(),
        next: /* @__PURE__ */ new Set()
      };
      this.allVertices[key2] = vertex;
    } else if (vertex.value === void 0) {
      vertex.value = value;
    }
    const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;
    if (!(options == null ? void 0 : options.after) && !(options == null ? void 0 : options.before) && !hasEdges) {
      this.isolatedVertices[key2] = vertex;
      this.emit("node:added", {
        key: key2,
        type: "isolated",
        value
      });
      return;
    } else {
      this.connectedVertices[key2] = vertex;
    }
    if (options == null ? void 0 : options.after) {
      const afterArr = Array.isArray(options.after) ? options.after : [options.after];
      afterArr.forEach((after) => {
        vertex.previous.add(this.getKey(after));
      });
      afterArr.forEach((after) => {
        const afterKey = this.getKey(after);
        const linkedAfter = this.allVertices[afterKey];
        if (!linkedAfter) {
          this.allVertices[afterKey] = {
            value: void 0,
            previous: /* @__PURE__ */ new Set(),
            next: /* @__PURE__ */ new Set([key2])
          };
          this.connectedVertices[afterKey] = this.allVertices[afterKey];
        } else {
          linkedAfter.next.add(key2);
          this.moveToConnected(afterKey);
        }
      });
    }
    if (options == null ? void 0 : options.before) {
      const beforeArr = Array.isArray(options.before) ? options.before : [options.before];
      beforeArr.forEach((before) => {
        vertex.next.add(this.getKey(before));
      });
      beforeArr.forEach((before) => {
        const beforeKey = this.getKey(before);
        const linkedBefore = this.allVertices[beforeKey];
        if (!linkedBefore) {
          this.allVertices[beforeKey] = {
            value: void 0,
            previous: /* @__PURE__ */ new Set([key2]),
            next: /* @__PURE__ */ new Set()
          };
          this.connectedVertices[beforeKey] = this.allVertices[beforeKey];
        } else {
          linkedBefore.previous.add(key2);
          this.moveToConnected(beforeKey);
        }
      });
    }
    this.emit("node:added", {
      key: key2,
      type: "connected",
      value
    });
    this.needsSort = true;
  }
  remove(key2) {
    const removeKey = this.getKey(key2);
    const unlinkedVertex = this.isolatedVertices[removeKey];
    if (unlinkedVertex) {
      delete this.isolatedVertices[removeKey];
      delete this.allVertices[removeKey];
      this.emit("node:removed", {
        key: removeKey,
        type: "isolated"
      });
      return;
    }
    const linkedVertex = this.connectedVertices[removeKey];
    if (!linkedVertex) {
      return;
    }
    linkedVertex.next.forEach((nextKey) => {
      const nextVertex = this.connectedVertices[nextKey];
      if (nextVertex) {
        nextVertex.previous.delete(removeKey);
        if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {
          this.moveToIsolated(nextKey);
        }
      }
    });
    linkedVertex.previous.forEach((prevKey) => {
      const prevVertex = this.connectedVertices[prevKey];
      if (prevVertex) {
        prevVertex.next.delete(removeKey);
        if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {
          this.moveToIsolated(prevKey);
        }
      }
    });
    delete this.connectedVertices[removeKey];
    delete this.allVertices[removeKey];
    this.emit("node:removed", {
      key: removeKey,
      type: "connected"
    });
    this.needsSort = true;
  }
  mapNodes(callback) {
    if (this.needsSort) {
      this.sort();
    }
    const result = [];
    this.forEachNode((value, index) => {
      result.push(callback(value, index));
    });
    return result;
  }
  forEachNode(callback) {
    if (this.needsSort) {
      this.sort();
    }
    let index = 0;
    for (; index < this.sortedConnectedValues.length; index++) {
      callback(this.sortedConnectedValues[index], index);
    }
    Reflect.ownKeys(this.isolatedVertices).forEach((key2) => {
      const vertex = this.isolatedVertices[key2];
      if (vertex.value !== void 0)
        callback(vertex.value, index++);
    });
  }
  getValueByKey(key2) {
    var _a;
    return (_a = this.allVertices[key2]) == null ? void 0 : _a.value;
  }
  getKeyByValue(value) {
    return Reflect.ownKeys(this.connectedVertices).find((key2) => this.connectedVertices[key2].value === value) ?? Reflect.ownKeys(this.isolatedVertices).find((key2) => this.isolatedVertices[key2].value === value);
  }
  sort() {
    var _a;
    const inDegree = /* @__PURE__ */ new Map();
    const zeroInDegreeQueue = [];
    const result = [];
    const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key2) => {
      const vertex = this.connectedVertices[key2];
      return vertex.value !== void 0;
    });
    connectedVertexKeysWithValues.forEach((vertex) => {
      inDegree.set(vertex, 0);
    });
    connectedVertexKeysWithValues.forEach((vertexKey) => {
      const vertex = this.connectedVertices[vertexKey];
      vertex.next.forEach((next) => {
        const nextVertex = this.connectedVertices[next];
        if (!nextVertex)
          return;
        inDegree.set(next, (inDegree.get(next) || 0) + 1);
      });
    });
    inDegree.forEach((degree, value) => {
      if (degree === 0) {
        zeroInDegreeQueue.push(value);
      }
    });
    while (zeroInDegreeQueue.length > 0) {
      const vertexKey = zeroInDegreeQueue.shift();
      result.push(vertexKey);
      const v = connectedVertexKeysWithValues.find((key2) => key2 === vertexKey);
      if (v) {
        (_a = this.connectedVertices[v]) == null ? void 0 : _a.next.forEach((adjVertex) => {
          const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;
          inDegree.set(adjVertex, adjVertexInDegree);
          if (adjVertexInDegree === 0) {
            zeroInDegreeQueue.push(adjVertex);
          }
        });
      }
    }
    if (result.length !== connectedVertexKeysWithValues.length) {
      throw new Error("The graph contains a cycle, and thus can not be sorted topologically.");
    }
    const filterUndefined = (value) => value !== void 0;
    this.sortedConnectedValues = result.map((key2) => this.connectedVertices[key2].value).filter(filterUndefined);
    this.needsSort = false;
  }
  clear() {
    this.allVertices = {};
    this.isolatedVertices = {};
    this.connectedVertices = {};
    this.sortedConnectedValues = [];
    this.needsSort = false;
  }
  static isKey(value) {
    return typeof value === "string" || typeof value === "symbol";
  }
  static isValue(value) {
    return typeof value === "object" && "key" in value;
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Task.js
var Task = class {
  constructor(stage, key2, callback) {
    __publicField(this, "key");
    __publicField(this, "stage");
    __publicField(this, "callback");
    __publicField(this, "runTask", true);
    this.stage = stage;
    this.key = key2;
    this.callback = callback;
  }
  stop() {
    this.runTask = false;
  }
  start() {
    this.runTask = true;
  }
  run(delta) {
    if (!this.runTask)
      return;
    this.callback(delta);
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Stage.js
var Stage = class extends DAG {
  constructor(scheduler, key2, callback) {
    super();
    __publicField(this, "key");
    __publicField(this, "scheduler");
    __publicField(this, "callback", (_, r) => r());
    __publicField(this, "removeTask", this.remove.bind(this));
    this.scheduler = scheduler;
    this.key = key2;
    if (callback)
      this.callback = callback.bind(this);
  }
  get tasks() {
    return this.sortedVertices;
  }
  createTask(key2, callback, options) {
    const task = new Task(this, key2, callback);
    this.add(key2, task, options);
    return task;
  }
  getTask(key2) {
    return this.getValueByKey(key2);
  }
  run(delta) {
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        task.run(deltaOverride ?? delta);
      });
    });
  }
  runWithTiming(delta) {
    const taskTimings = {};
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        const start = performance.now();
        task.run(deltaOverride ?? delta);
        const duration = performance.now() - start;
        taskTimings[task.key] = duration;
      });
    });
    return taskTimings;
  }
  getSchedule() {
    return this.mapNodes((l) => l.key.toString());
  }
};

// node_modules/@threlte/core/dist/frame-scheduling/Scheduler.js
var Scheduler = class extends DAG {
  constructor(options) {
    super();
    __publicField(this, "lastTime", performance.now());
    __publicField(this, "clampDeltaTo", 0.1);
    __publicField(this, "removeStage", this.remove.bind(this));
    if (options == null ? void 0 : options.clampDeltaTo)
      this.clampDeltaTo = options.clampDeltaTo;
    this.run = this.run.bind(this);
  }
  get stages() {
    return this.sortedVertices;
  }
  createStage(key2, options) {
    const stage = new Stage(this, key2, options == null ? void 0 : options.callback);
    this.add(key2, stage, {
      after: options == null ? void 0 : options.after,
      before: options == null ? void 0 : options.before
    });
    return stage;
  }
  getStage(key2) {
    return this.getValueByKey(key2);
  }
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(time) {
    const delta = time - this.lastTime;
    this.forEachNode((stage) => {
      stage.run(Math.min(delta / 1e3, this.clampDeltaTo));
    });
    this.lastTime = time;
  }
  runWithTiming(time) {
    const delta = time - this.lastTime;
    const stageTimings = {};
    const start = performance.now();
    this.forEachNode((stage) => {
      const start2 = performance.now();
      const taskTimings = stage.runWithTiming(Math.min(delta / 1e3, this.clampDeltaTo));
      const duration = performance.now() - start2;
      stageTimings[stage.key.toString()] = {
        duration,
        tasks: taskTimings
      };
    });
    return {
      total: performance.now() - start,
      stages: stageTimings
    };
  }
  getSchedule(include = {
    tasks: true
  }) {
    return {
      stages: this.mapNodes((stage) => {
        if (stage === void 0)
          throw new Error("Stage not found");
        return {
          key: stage.key.toString(),
          ...{ tasks: include.tasks ? stage.getSchedule() : void 0 }
        };
      })
    };
  }
  dispose() {
    this.clear();
  }
};

// node_modules/@threlte/core/dist/lib/storeUtils.js
var watch = (stores, callback) => {
  const d = derived(stores, (values) => {
    return values;
  });
  let cleanupFn;
  const unsubscribe = d.subscribe(async (values) => {
    if (cleanupFn)
      cleanupFn();
    const fn = await callback(values);
    if (fn)
      cleanupFn = fn;
  });
  onDestroy(() => {
    unsubscribe();
    if (cleanupFn)
      cleanupFn();
  });
};
function memoize(stores, transform) {
  const obj = {
    current: void 0
  };
  watch(stores, (v) => {
    obj.current = transform ? transform(v) : v;
  });
  return obj;
}
var currentWritable = (value) => {
  const store = writable(value);
  const extendedWritable = {
    set: (value2) => {
      extendedWritable.current = value2;
      store.set(value2);
    },
    subscribe: store.subscribe,
    update: (fn) => {
      const newValue = fn(extendedWritable.current);
      extendedWritable.current = newValue;
      store.set(newValue);
    },
    current: value
  };
  return extendedWritable;
};

// node_modules/@threlte/core/dist/lib/defaultCamera.js
var defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
defaultCamera.position.z = 5;
defaultCamera.lookAt(0, 0, 0);
var getDefaultCamera = () => defaultCamera;
var setDefaultCameraAspectOnSizeChange = (ctx) => {
  watch(ctx.size, (size) => {
    if (ctx.camera.current === defaultCamera) {
      const cam = ctx.camera.current;
      cam.aspect = size.width / size.height;
      cam.updateProjectionMatrix();
      ctx.invalidate();
    }
  });
};

// node_modules/@threlte/core/dist/hooks/legacy/utils.js
var orderToKey = (order) => `useFrame-order-${order.toString()}`;
var useLegacyFrameCompatibilityContextKey = Symbol("use-legacy-frame-compatibility-context");
var injectLegacyFrameCompatibilityContext = () => {
  const ctx = {
    useFrameOrders: [],
    useRenderOrders: []
  };
  setContext(useLegacyFrameCompatibilityContextKey, ctx);
  return ctx;
};
var useLegacyFrameCompatibilityContext = () => {
  const ctx = getContext(useLegacyFrameCompatibilityContextKey);
  if (ctx === void 0) {
    throw new Error("No legacy frame compatibility context found, are you using this hook inside of <Canvas>?");
  }
  return ctx;
};

// node_modules/@threlte/core/dist/lib/contexts.js
var createThrelteContext = (options) => {
  const internalCtx = {
    frameInvalidated: true,
    advance: false,
    autoInvalidations: /* @__PURE__ */ new Set(),
    resetFrameInvalidation: () => {
      internalCtx.frameInvalidated = false;
      internalCtx.advance = false;
    },
    dispose: async (force = false) => {
      await tick();
      if (!internalCtx.shouldDispose && !force)
        return;
      internalCtx.disposableObjects.forEach((mounted, object) => {
        var _a;
        if (mounted === 0 || force) {
          (_a = object == null ? void 0 : object.dispose) == null ? void 0 : _a.call(object);
          internalCtx.disposableObjects.delete(object);
        }
      });
      internalCtx.shouldDispose = false;
    },
    collectDisposableObjects: (object, objects) => {
      const disposables = objects ?? [];
      if (!object)
        return disposables;
      if ((object == null ? void 0 : object.dispose) && typeof object.dispose === "function" && object.type !== "Scene") {
        disposables.push(object);
      }
      Object.entries(object).forEach(([propKey, propValue]) => {
        if (propKey === "parent" || propKey === "children" || typeof propValue !== "object")
          return;
        const value = propValue;
        if (value == null ? void 0 : value.dispose) {
          internalCtx.collectDisposableObjects(value, disposables);
        }
      });
      return disposables;
    },
    addDisposableObjects: (objects) => {
      objects.forEach((obj) => {
        const currentValue = internalCtx.disposableObjects.get(obj);
        if (currentValue) {
          internalCtx.disposableObjects.set(obj, currentValue + 1);
        } else {
          internalCtx.disposableObjects.set(obj, 1);
        }
      });
    },
    removeDisposableObjects: (objects) => {
      if (objects.length === 0)
        return;
      objects.forEach((obj) => {
        const currentValue = internalCtx.disposableObjects.get(obj);
        if (currentValue && currentValue > 0) {
          internalCtx.disposableObjects.set(obj, currentValue - 1);
        }
      });
      internalCtx.shouldDispose = true;
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: false
  };
  const { useRenderOrders } = injectLegacyFrameCompatibilityContext();
  const scheduler = new Scheduler();
  const mainStage = scheduler.createStage(Symbol("threlte-main-stage"));
  const renderStage = scheduler.createStage(Symbol("threlte-render-stage"), {
    after: mainStage,
    callback(_, runTasks) {
      if (ctx.shouldRender())
        runTasks();
    }
  });
  const autoRenderTask = renderStage.createTask(Symbol("threlte-auto-render-task"), (_) => {
    if (useRenderOrders.length > 0)
      return;
    ctx.renderer.render(ctx.scene, ctx.camera.current);
  });
  const ctx = {
    size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {
      return uSize ? uSize : pSize;
    }),
    camera: currentWritable(getDefaultCamera()),
    scene: new Scene(),
    renderer: void 0,
    invalidate: () => {
      internalCtx.frameInvalidated = true;
    },
    advance: () => {
      internalCtx.advance = true;
    },
    colorSpace: currentWritable(options.colorSpace),
    toneMapping: currentWritable(options.toneMapping),
    dpr: currentWritable(options.dpr),
    useLegacyLights: currentWritable(options.useLegacyLights),
    shadows: currentWritable(options.shadows),
    colorManagementEnabled: currentWritable(options.colorManagementEnabled),
    renderMode: currentWritable(options.renderMode),
    autoRender: currentWritable(options.autoRender),
    scheduler,
    mainStage,
    renderStage,
    autoRenderTask,
    shouldRender: () => {
      const shouldRender = ctx.renderMode.current === "always" || ctx.renderMode.current === "on-demand" && (internalCtx.frameInvalidated || internalCtx.autoInvalidations.size > 0) || ctx.renderMode.current === "manual" && internalCtx.advance;
      return shouldRender;
    }
  };
  setDefaultCameraAspectOnSizeChange(ctx);
  const userCtx = currentWritable({});
  setContext("threlte", ctx);
  setContext("threlte-internal-context", internalCtx);
  setContext("threlte-user-context", userCtx);
  return ctx;
};

// node_modules/@threlte/core/dist/lib/browser.js
var browser = typeof window !== "undefined";

// node_modules/@threlte/core/dist/hooks/useParentSize.js
var useParentSize = () => {
  const parentSize = currentWritable({ width: 0, height: 0 });
  if (!browser) {
    return {
      parentSize,
      parentSizeAction: () => {
      }
    };
  }
  const mutationOptions = { childList: true, subtree: false, attributes: false };
  let el;
  const observeParent = (parent) => {
    resizeObserver.disconnect();
    mutationObserver.disconnect();
    resizeObserver.observe(parent);
    mutationObserver.observe(parent, mutationOptions);
  };
  const resizeObserver = new ResizeObserver(([entry]) => {
    const { width, height } = entry.contentRect;
    if (width === parentSize.current.width && height === parentSize.current.height)
      return;
    parentSize.set({ width, height });
  });
  const mutationObserver = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      for (const node of mutation.removedNodes) {
        if (el === node && el.parentElement) {
          observeParent(el.parentElement);
          return;
        }
      }
    }
  });
  const parentSizeAction = (node) => {
    el = node;
    const parent = el.parentElement;
    if (!parent)
      return;
    parentSize.set({
      width: parent.clientWidth,
      height: parent.clientHeight
    });
    observeParent(parent);
  };
  onDestroy(() => {
    resizeObserver.disconnect();
    mutationObserver.disconnect();
  });
  return {
    parentSize,
    parentSizeAction
  };
};

// node_modules/@threlte/core/dist/lib/createObjectStore.js
function createObjectStore(object, onChange) {
  const objectStore = writable(object);
  let unwrappedObject = object;
  const unsubscribeObjectStore = objectStore.subscribe((o) => unwrappedObject = o);
  onDestroy(unsubscribeObjectStore);
  const set = (newObject) => {
    if ((newObject == null ? void 0 : newObject.uuid) === (unwrappedObject == null ? void 0 : unwrappedObject.uuid))
      return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange == null ? void 0 : onChange(newObject, oldObject);
  };
  const update = (callback) => {
    const newObject = callback(unwrappedObject);
    if ((newObject == null ? void 0 : newObject.uuid) === (unwrappedObject == null ? void 0 : unwrappedObject.uuid))
      return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange == null ? void 0 : onChange(newObject, oldObject);
  };
  return {
    ...objectStore,
    set,
    update
  };
}

// node_modules/@threlte/core/dist/hooks/useThrelte.js
var useThrelte = () => {
  const context = getContext("threlte");
  if (context === void 0) {
    throw new Error("No Threlte context found, are you using this hook inside of <Canvas>?");
  }
  return context;
};

// node_modules/@threlte/core/dist/hooks/useParent.js
var key = Symbol("threlte-hierarchical-parent-context");
var useParent = () => {
  return getContext(key);
};
var setParent = (context) => {
  return setContext(key, context);
};
var createParentContext = (ref) => {
  const context = createObjectStore(ref);
  setContext(key, context);
  return context;
};

// node_modules/@threlte/core/dist/internal/HierarchicalObject.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var useHierarchicalObject = () => {
  return {
    onChildMount: getContext("threlte-hierarchical-object-on-mount"),
    onChildDestroy: getContext("threlte-hierarchical-object-on-destroy")
  };
};
function instance($$self, $$props, $$invalidate) {
  var _a;
  let $parentStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HierarchicalObject", slots, ["default"]);
  let { object = void 0 } = $$props;
  let { onChildMount = void 0 } = $$props;
  const onChildMountProxy = (child) => {
    onChildMount == null ? void 0 : onChildMount(child);
  };
  let { onChildDestroy = void 0 } = $$props;
  const onChildDestroyProxy = (child) => {
    onChildDestroy == null ? void 0 : onChildDestroy(child);
  };
  const { invalidate } = useThrelte();
  const parentStore = useParent();
  validate_store(parentStore, "parentStore");
  component_subscribe($$self, parentStore, (value) => $$invalidate(5, $parentStore = value));
  let { parent = $parentStore } = $$props;
  const parentCallbacks = useHierarchicalObject();
  if (object) {
    (_a = parentCallbacks.onChildMount) == null ? void 0 : _a.call(parentCallbacks, object);
    invalidate();
  }
  const objectStore = createObjectStore(object, (newObject, oldObject) => {
    var _a2, _b;
    if (oldObject) {
      (_a2 = parentCallbacks.onChildDestroy) == null ? void 0 : _a2.call(parentCallbacks, oldObject);
      invalidate();
    }
    if (newObject) {
      (_b = parentCallbacks.onChildMount) == null ? void 0 : _b.call(parentCallbacks, newObject);
      invalidate();
    }
  });
  onDestroy(() => {
    var _a2;
    if (object) {
      (_a2 = parentCallbacks.onChildDestroy) == null ? void 0 : _a2.call(parentCallbacks, object);
      invalidate();
    }
  });
  setContext("threlte-hierarchical-object-on-mount", onChildMountProxy);
  setContext("threlte-hierarchical-object-on-destroy", onChildDestroyProxy);
  setParent(objectStore);
  const writable_props = ["object", "onChildMount", "onChildDestroy", "parent"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<HierarchicalObject> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2) $$invalidate(2, object = $$props2.object);
    if ("onChildMount" in $$props2) $$invalidate(3, onChildMount = $$props2.onChildMount);
    if ("onChildDestroy" in $$props2) $$invalidate(4, onChildDestroy = $$props2.onChildDestroy);
    if ("parent" in $$props2) $$invalidate(1, parent = $$props2.parent);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    useParent,
    setParent,
    useThrelte,
    createObjectStore,
    useHierarchicalObject,
    object,
    onChildMount,
    onChildMountProxy,
    onChildDestroy,
    onChildDestroyProxy,
    invalidate,
    parentStore,
    parent,
    parentCallbacks,
    objectStore,
    $parentStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2) $$invalidate(2, object = $$props2.object);
    if ("onChildMount" in $$props2) $$invalidate(3, onChildMount = $$props2.onChildMount);
    if ("onChildDestroy" in $$props2) $$invalidate(4, onChildDestroy = $$props2.onChildDestroy);
    if ("parent" in $$props2) $$invalidate(1, parent = $$props2.parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$parentStore*/
    32) {
      $: $$invalidate(1, parent = $parentStore);
    }
    if ($$self.$$.dirty & /*object*/
    4) {
      $: objectStore.set(object);
    }
  };
  return [
    parentStore,
    parent,
    object,
    onChildMount,
    onChildDestroy,
    $parentStore,
    $$scope,
    slots
  ];
}
var HierarchicalObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      object: 2,
      onChildMount: 3,
      onChildDestroy: 4,
      parent: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HierarchicalObject",
      options,
      id: create_fragment.name
    });
  }
  get object() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChildMount() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChildMount(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onChildDestroy() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onChildDestroy(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<HierarchicalObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<HierarchicalObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HierarchicalObject_default = HierarchicalObject;

// node_modules/@threlte/core/dist/internal/SceneGraphObject.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(5:0) <HierarchicalObject   {object}   onChildMount={(child) => object.add(child)}   onChildDestroy={(child) => object.remove(child)} >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let hierarchicalobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      object: (
        /*object*/
        ctx[0]
      ),
      onChildMount: (
        /*func*/
        ctx[2]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*object*/
      1) hierarchicalobject_changes.object = /*object*/
      ctx2[0];
      if (dirty & /*object*/
      1) hierarchicalobject_changes.onChildMount = /*func*/
      ctx2[2];
      if (dirty & /*object*/
      1) hierarchicalobject_changes.onChildDestroy = /*func_1*/
      ctx2[3];
      if (dirty & /*$$scope*/
      16) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hierarchicalobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SceneGraphObject", slots, ["default"]);
  let { object } = $$props;
  $$self.$$.on_mount.push(function() {
    if (object === void 0 && !("object" in $$props || $$self.$$.bound[$$self.$$.props["object"]])) {
      console.warn("<SceneGraphObject> was created without expected prop 'object'");
    }
  });
  const writable_props = ["object"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<SceneGraphObject> was created with unknown prop '${key2}'`);
  });
  const func = (child) => object.add(child);
  const func_1 = (child) => object.remove(child);
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2) $$invalidate(0, object = $$props2.object);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ HierarchicalObject: HierarchicalObject_default, object });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2) $$invalidate(0, object = $$props2.object);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [object, slots, func, func_1, $$scope];
}
var SceneGraphObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { object: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SceneGraphObject",
      options,
      id: create_fragment2.name
    });
  }
  get object() {
    throw new Error("<SceneGraphObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<SceneGraphObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SceneGraphObject_default = SceneGraphObject;

// node_modules/@threlte/core/dist/lib/cache.js
var shallowEqualArrays = (arrA, arrB) => {
  if (arrA === arrB)
    return true;
  if (!arrA || !arrB)
    return false;
  const len = arrA.length;
  if (arrB.length !== len)
    return false;
  for (let i = 0; i < len; i++)
    if (arrA[i] !== arrB[i])
      return false;
  return true;
};
var createCache = () => {
  setContext("threlte-cache", []);
};
var useCache = () => {
  const cache = getContext("threlte-cache");
  if (!cache) {
    throw new Error("No cache found. The cache can only be used in a child component to <Canvas>.");
  }
  const remember = (callback, keys) => {
    for (const entry2 of cache) {
      if (shallowEqualArrays(keys, entry2.keys)) {
        if (entry2.error)
          throw entry2.error;
        if (entry2.promise)
          return entry2.promise;
      }
    }
    const entry = {
      promise: callback(),
      keys,
      value: void 0
    };
    cache.push(entry);
    entry.promise.catch((error) => {
      entry.error = error;
    });
    return entry.promise;
  };
  const clear = (keys) => {
    const index = cache.findIndex((entry) => shallowEqualArrays(keys, entry.keys));
    if (index !== -1) {
      cache.splice(index, 1);
    }
  };
  return {
    remember,
    clear
  };
};

// node_modules/@threlte/core/dist/lib/revision.js
var normalizedRevision = REVISION.replace("dev", "");
var revision = Number.parseInt(normalizedRevision);

// node_modules/@threlte/core/dist/lib/useRenderer.js
var useRenderer = (ctx) => {
  const renderer = writable(void 0);
  const createRenderer = (canvas, rendererParameters) => {
    ctx.renderer = new WebGLRenderer({
      powerPreference: "high-performance",
      canvas,
      antialias: true,
      alpha: true,
      ...rendererParameters
    });
    renderer.set(ctx.renderer);
  };
  watch([ctx.colorManagementEnabled], ([colorManagementEnabled]) => {
    ColorManagement.enabled = colorManagementEnabled;
  });
  watch([renderer, ctx.colorSpace], ([renderer2, colorSpace]) => {
    if (!renderer2)
      return;
    renderer2.outputColorSpace = colorSpace;
  });
  watch([renderer, ctx.dpr], ([renderer2, dpr]) => {
    renderer2 == null ? void 0 : renderer2.setPixelRatio(dpr);
  });
  watch([renderer, ctx.size], ([renderer2, size]) => {
    var _a;
    if ((_a = renderer2 == null ? void 0 : renderer2.xr) == null ? void 0 : _a.isPresenting)
      return;
    renderer2 == null ? void 0 : renderer2.setSize(size.width, size.height);
  });
  watch([renderer, ctx.shadows], ([renderer2, shadows]) => {
    if (!renderer2)
      return;
    renderer2.shadowMap.enabled = !!shadows;
    if (shadows && shadows !== true) {
      renderer2.shadowMap.type = shadows;
    } else if (shadows === true) {
      renderer2.shadowMap.type = PCFSoftShadowMap;
    }
  });
  watch([renderer, ctx.toneMapping], ([renderer2, toneMapping]) => {
    if (!renderer2)
      return;
    renderer2.toneMapping = toneMapping;
  });
  watch([renderer, ctx.useLegacyLights], ([renderer2, useLegacyLights]) => {
    if (!renderer2)
      return;
    if (useLegacyLights) {
      renderer2.useLegacyLights = useLegacyLights;
    }
  });
  return {
    createRenderer
  };
};

// node_modules/@threlte/core/dist/hooks/useThrelteInternal.js
var useThrelteInternal = () => {
  return getContext("threlte-internal-context");
};

// node_modules/@threlte/core/dist/Canvas.svelte
var file = "node_modules\\@threlte\\core\\dist\\Canvas.svelte";
function add_css(target) {
  append_styles(target, "svelte-o3oskp", "canvas.svelte-o3oskp{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FudmFzLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJEOlxcQ09ERSBCQVNFXFx3b3JraW5nIHdlbGwgc2tsZXRvblxcV09SS0lORyBXRUxMXFxub2RlX21vZHVsZXNcXEB0aHJlbHRlXFxjb3JlXFxkaXN0XFxDYW52YXMuc3ZlbHRlIl19 */");
}
function create_if_block(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*ctx*/
        ctx[0].scene
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scenegraphobject_changes = {};
      if (dirty & /*$$scope*/
      131072) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(130:2) {#if $initialized}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(131:4) <SceneGraphObject object={ctx.scene}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let canvas_1;
  let parentSizeAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$initialized*/
    ctx[2] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      canvas_1 = element("canvas");
      if (if_block) if_block.c();
      attr_dev(canvas_1, "class", "svelte-o3oskp");
      add_location(canvas_1, file, 125, 0, 3845);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas_1, anchor);
      if (if_block) if_block.m(canvas_1, null);
      ctx[16](canvas_1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(parentSizeAction_action = /*parentSizeAction*/
        ctx[4].call(null, canvas_1));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$initialized*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$initialized*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(canvas_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(canvas_1);
      }
      if (if_block) if_block.d();
      ctx[16](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $initialized;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Canvas", slots, ["default"]);
  let { colorManagementEnabled = true } = $$props;
  let { colorSpace = "srgb" } = $$props;
  let { dpr = browser ? window.devicePixelRatio : 1 } = $$props;
  let { renderMode = "on-demand" } = $$props;
  let { rendererParameters = void 0 } = $$props;
  let { shadows = PCFSoftShadowMap } = $$props;
  let { size = void 0 } = $$props;
  let { toneMapping = ACESFilmicToneMapping } = $$props;
  let { useLegacyLights = revision >= 155 ? false : true } = $$props;
  let { autoRender = true } = $$props;
  let canvas;
  let initialized = writable(false);
  validate_store(initialized, "initialized");
  component_subscribe($$self, initialized, (value) => $$invalidate(2, $initialized = value));
  const userSize = writable(size);
  const { parentSize, parentSizeAction } = useParentSize();
  const context = createThrelteContext({
    colorManagementEnabled,
    colorSpace,
    dpr,
    renderMode,
    parentSize,
    autoRender,
    shadows,
    toneMapping,
    useLegacyLights,
    userSize
  });
  const internalCtx = useThrelteInternal();
  const ctx = context;
  watch([initialized, ctx.autoRender], ([initialized2, autoRender2]) => {
    if (initialized2 && autoRender2) {
      ctx.autoRenderTask.start();
    } else {
      ctx.autoRenderTask.stop();
    }
    return () => {
      ctx.autoRenderTask.stop();
    };
  });
  createCache();
  const { createRenderer } = useRenderer(ctx);
  onMount(() => {
    createRenderer(canvas, rendererParameters);
    ctx.renderer.setAnimationLoop((time) => {
      internalCtx.dispose();
      ctx.scheduler.run(time);
      internalCtx.resetFrameInvalidation();
    });
    initialized.set(true);
  });
  onDestroy(() => {
    var _a;
    internalCtx.dispose(true);
    ctx.scheduler.dispose();
    (_a = ctx.renderer) == null ? void 0 : _a.dispose();
  });
  const writable_props = [
    "colorManagementEnabled",
    "colorSpace",
    "dpr",
    "renderMode",
    "rendererParameters",
    "shadows",
    "size",
    "toneMapping",
    "useLegacyLights",
    "autoRender"
  ];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<Canvas> was created with unknown prop '${key2}'`);
  });
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(1, canvas);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("colorManagementEnabled" in $$props2) $$invalidate(5, colorManagementEnabled = $$props2.colorManagementEnabled);
    if ("colorSpace" in $$props2) $$invalidate(6, colorSpace = $$props2.colorSpace);
    if ("dpr" in $$props2) $$invalidate(7, dpr = $$props2.dpr);
    if ("renderMode" in $$props2) $$invalidate(8, renderMode = $$props2.renderMode);
    if ("rendererParameters" in $$props2) $$invalidate(9, rendererParameters = $$props2.rendererParameters);
    if ("shadows" in $$props2) $$invalidate(10, shadows = $$props2.shadows);
    if ("size" in $$props2) $$invalidate(11, size = $$props2.size);
    if ("toneMapping" in $$props2) $$invalidate(12, toneMapping = $$props2.toneMapping);
    if ("useLegacyLights" in $$props2) $$invalidate(13, useLegacyLights = $$props2.useLegacyLights);
    if ("autoRender" in $$props2) $$invalidate(14, autoRender = $$props2.autoRender);
    if ("$$scope" in $$props2) $$invalidate(17, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    writable,
    ACESFilmicToneMapping,
    PCFSoftShadowMap,
    createThrelteContext,
    useParentSize,
    SceneGraphObject: SceneGraphObject_default,
    browser,
    createCache,
    revision,
    watch,
    useRenderer,
    useThrelteInternal,
    colorManagementEnabled,
    colorSpace,
    dpr,
    renderMode,
    rendererParameters,
    shadows,
    size,
    toneMapping,
    useLegacyLights,
    autoRender,
    canvas,
    initialized,
    userSize,
    parentSize,
    parentSizeAction,
    context,
    internalCtx,
    ctx,
    createRenderer,
    $initialized
  });
  $$self.$inject_state = ($$props2) => {
    if ("colorManagementEnabled" in $$props2) $$invalidate(5, colorManagementEnabled = $$props2.colorManagementEnabled);
    if ("colorSpace" in $$props2) $$invalidate(6, colorSpace = $$props2.colorSpace);
    if ("dpr" in $$props2) $$invalidate(7, dpr = $$props2.dpr);
    if ("renderMode" in $$props2) $$invalidate(8, renderMode = $$props2.renderMode);
    if ("rendererParameters" in $$props2) $$invalidate(9, rendererParameters = $$props2.rendererParameters);
    if ("shadows" in $$props2) $$invalidate(10, shadows = $$props2.shadows);
    if ("size" in $$props2) $$invalidate(11, size = $$props2.size);
    if ("toneMapping" in $$props2) $$invalidate(12, toneMapping = $$props2.toneMapping);
    if ("useLegacyLights" in $$props2) $$invalidate(13, useLegacyLights = $$props2.useLegacyLights);
    if ("autoRender" in $$props2) $$invalidate(14, autoRender = $$props2.autoRender);
    if ("canvas" in $$props2) $$invalidate(1, canvas = $$props2.canvas);
    if ("initialized" in $$props2) $$invalidate(3, initialized = $$props2.initialized);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    2048) {
      $: userSize.set(size);
    }
    if ($$self.$$.dirty & /*colorSpace*/
    64) {
      $: ctx.colorSpace.set(colorSpace);
    }
    if ($$self.$$.dirty & /*dpr*/
    128) {
      $: ctx.dpr.set(dpr);
    }
    if ($$self.$$.dirty & /*renderMode*/
    256) {
      $: ctx.renderMode.set(renderMode);
    }
    if ($$self.$$.dirty & /*autoRender*/
    16384) {
      $: ctx.autoRender.set(autoRender);
    }
    if ($$self.$$.dirty & /*shadows*/
    1024) {
      $: ctx.shadows.set(shadows);
    }
    if ($$self.$$.dirty & /*toneMapping*/
    4096) {
      $: ctx.toneMapping.set(toneMapping);
    }
  };
  return [
    ctx,
    canvas,
    $initialized,
    initialized,
    parentSizeAction,
    colorManagementEnabled,
    colorSpace,
    dpr,
    renderMode,
    rendererParameters,
    shadows,
    size,
    toneMapping,
    useLegacyLights,
    autoRender,
    slots,
    canvas_1_binding,
    $$scope
  ];
}
var Canvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        colorManagementEnabled: 5,
        colorSpace: 6,
        dpr: 7,
        renderMode: 8,
        rendererParameters: 9,
        shadows: 10,
        size: 11,
        toneMapping: 12,
        useLegacyLights: 13,
        autoRender: 14,
        ctx: 0
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Canvas",
      options,
      id: create_fragment3.name
    });
  }
  get colorManagementEnabled() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorManagementEnabled(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colorSpace() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colorSpace(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dpr() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dpr(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderMode() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderMode(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rendererParameters() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rendererParameters(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadows() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadows(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toneMapping() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toneMapping(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useLegacyLights() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useLegacyLights(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoRender() {
    throw new Error("<Canvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoRender(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ctx() {
    return this.$$.ctx[0];
  }
  set ctx(value) {
    throw new Error("<Canvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Canvas_default = Canvas;

// node_modules/@threlte/core/dist/internal/DisposableObject.svelte
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var contextName = "threlte-disposable-object-context";
function instance4($$self, $$props, $$invalidate) {
  let $mergedDispose;
  let $parentDispose;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DisposableObject", slots, ["default"]);
  const { collectDisposableObjects, addDisposableObjects, removeDisposableObjects } = useThrelteInternal();
  let { object = void 0 } = $$props;
  let previousObject = object;
  let { dispose = void 0 } = $$props;
  const parentDispose = getContext(contextName);
  validate_store(parentDispose, "parentDispose");
  component_subscribe($$self, parentDispose, (value) => $$invalidate(7, $parentDispose = value));
  const mergedDispose = writable(dispose ?? $parentDispose ?? true);
  validate_store(mergedDispose, "mergedDispose");
  component_subscribe($$self, mergedDispose, (value) => $$invalidate(6, $mergedDispose = value));
  setContext(contextName, mergedDispose);
  let disposables = $mergedDispose ? collectDisposableObjects(object) : [];
  addDisposableObjects(disposables);
  onDestroy(() => {
    removeDisposableObjects(disposables);
  });
  const writable_props = ["object", "dispose"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot") console.warn(`<DisposableObject> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("object" in $$props2) $$invalidate(2, object = $$props2.object);
    if ("dispose" in $$props2) $$invalidate(3, dispose = $$props2.dispose);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    setContext,
    writable,
    useThrelteInternal,
    collectDisposableObjects,
    addDisposableObjects,
    removeDisposableObjects,
    object,
    previousObject,
    dispose,
    contextName,
    parentDispose,
    mergedDispose,
    disposables,
    $mergedDispose,
    $parentDispose
  });
  $$self.$inject_state = ($$props2) => {
    if ("object" in $$props2) $$invalidate(2, object = $$props2.object);
    if ("previousObject" in $$props2) $$invalidate(4, previousObject = $$props2.previousObject);
    if ("dispose" in $$props2) $$invalidate(3, dispose = $$props2.dispose);
    if ("disposables" in $$props2) $$invalidate(5, disposables = $$props2.disposables);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dispose, $parentDispose*/
    136) {
      $: mergedDispose.set(dispose ?? $parentDispose ?? true);
    }
    if ($$self.$$.dirty & /*object, previousObject, disposables, $mergedDispose*/
    116) {
      $: {
        if (object !== previousObject) {
          removeDisposableObjects(disposables);
          $$invalidate(5, disposables = $mergedDispose ? collectDisposableObjects(object) : []);
          addDisposableObjects(disposables);
          $$invalidate(4, previousObject = object);
        }
      }
    }
  };
  return [
    parentDispose,
    mergedDispose,
    object,
    dispose,
    previousObject,
    disposables,
    $mergedDispose,
    $parentDispose,
    $$scope,
    slots
  ];
}
var DisposableObject = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { object: 2, dispose: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DisposableObject",
      options,
      id: create_fragment4.name
    });
  }
  get object() {
    throw new Error("<DisposableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<DisposableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<DisposableObject>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<DisposableObject>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DisposableObject_default = DisposableObject;

// node_modules/@threlte/core/dist/components/T/utils/utils.js
var classRegex = /^\s*class\s+/;
var isClass = (input) => {
  if (typeof input !== "function") {
    return false;
  }
  return classRegex.test(input.toString());
};
var argsIsConstructorParameters = (args) => {
  return Array.isArray(args);
};
var determineRef = (is, args) => {
  if (isClass(is)) {
    if (argsIsConstructorParameters(args)) {
      return new is(...args);
    } else {
      return new is();
    }
  }
  return is;
};
var extendsObject3D = (object) => {
  return "isObject3D" in object;
};
var isDisposableObject = (object) => {
  return "dispose" in object;
};

// node_modules/@threlte/core/dist/components/T/utils/resolvePropertyPath.js
var resolvePropertyPath = (target, propertyPath) => {
  if (propertyPath.includes(".")) {
    const path = propertyPath.split(".");
    const key2 = path.pop();
    for (let i = 0; i < path.length; i += 1) {
      target = target[path[i]];
    }
    return {
      target,
      key: key2
    };
  } else {
    return {
      target,
      key: propertyPath
    };
  }
};

// node_modules/@threlte/core/dist/components/T/utils/useAttach.js
var initialValueBeforeAttach = Symbol("initialValueBeforeAttach");
var useAttach = () => {
  const { invalidate } = useThrelte();
  let isAttached = false;
  let valueBeforeAttach = initialValueBeforeAttach;
  let detachFn;
  let attachedTo;
  let attachedKey;
  const update = (instance6, parent, attach) => {
    detach();
    if (!attach) {
      const i = instance6;
      const isMaterial = (i == null ? void 0 : i.isMaterial) || false;
      if (isMaterial) {
        attach = "material";
      }
      const isGeometry = (i == null ? void 0 : i.isBufferGeometry) || (i == null ? void 0 : i.isGeometry) || false;
      if (isGeometry) {
        attach = "geometry";
      }
    }
    if (!attach)
      return;
    if (typeof attach === "function") {
      detachFn = attach(parent, instance6);
    } else {
      const { target, key: key2 } = resolvePropertyPath(parent, attach);
      valueBeforeAttach = target[key2];
      target[key2] = instance6;
      attachedTo = target;
      attachedKey = key2;
    }
    isAttached = true;
    invalidate();
  };
  const detach = () => {
    if (!isAttached)
      return;
    if (detachFn) {
      detachFn();
      detachFn = void 0;
    } else if (attachedTo && attachedKey && valueBeforeAttach !== initialValueBeforeAttach) {
      attachedTo[attachedKey] = valueBeforeAttach;
      valueBeforeAttach = initialValueBeforeAttach;
      attachedTo = void 0;
      attachedKey = void 0;
    }
    isAttached = false;
    invalidate();
  };
  onDestroy(() => {
    detach();
  });
  return {
    update
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useCamera.js
var isCamera = (value) => {
  return value && value.isCamera;
};
var isOrthographicCamera = (value) => {
  return value && value.isOrthographicCamera;
};
var isPerspectiveCamera = (value) => {
  return value && value.isPerspectiveCamera;
};
var isPerspectiveCameraOrOrthographicCamera = (value) => {
  return isPerspectiveCamera(value) || isOrthographicCamera(value);
};
var useCamera = () => {
  const { invalidate, size, camera } = useThrelte();
  let currentInstance;
  let unsubscribe = void 0;
  onDestroy(() => {
    unsubscribe == null ? void 0 : unsubscribe();
  });
  const subscriber = (size2) => {
    if (!currentInstance)
      return;
    if (isOrthographicCamera(currentInstance)) {
      currentInstance.left = size2.width / -2;
      currentInstance.right = size2.width / 2;
      currentInstance.top = size2.height / 2;
      currentInstance.bottom = size2.height / -2;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    } else if (isPerspectiveCamera(currentInstance)) {
      currentInstance.aspect = size2.width / size2.height;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    }
  };
  const update = (instance6, manual) => {
    unsubscribe == null ? void 0 : unsubscribe();
    if (manual || !isPerspectiveCameraOrOrthographicCamera(instance6)) {
      currentInstance = void 0;
      return;
    }
    currentInstance = instance6;
    unsubscribe = size.subscribe(subscriber);
  };
  const makeDefaultCamera = (instance6, makeDefault) => {
    if (!isCamera(instance6) || !makeDefault)
      return;
    camera.set(instance6);
    invalidate();
  };
  return {
    update,
    makeDefaultCamera
  };
};

// node_modules/@threlte/core/dist/lib/createRawEventDispatcher.js
var createRawEventDispatcher = () => {
  const component = get_current_component();
  const dispatchRawEvent = (type, value) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      callbacks.forEach((fn) => {
        fn(value);
      });
    }
  };
  const hasEventListener = (type) => {
    return Boolean(component.$$.callbacks[type]);
  };
  Object.defineProperty(dispatchRawEvent, "hasEventListener", {
    value: hasEventListener,
    enumerable: true
  });
  return dispatchRawEvent;
};

// node_modules/@threlte/core/dist/components/T/utils/useCreateEvent.js
var useCreateEvent = () => {
  const dispatchRaw = createRawEventDispatcher();
  const cleanupFunctions = [];
  let ref = void 0;
  let mounted = false;
  const dispatchCreateEvent = () => {
    cleanupFunctions.forEach((cleanup2) => cleanup2());
    cleanupFunctions.length = 0;
    const cleanup = (callback) => {
      cleanupFunctions.push(callback);
    };
    dispatchRaw("create", { ref, cleanup });
  };
  const updateRef = (newRef) => {
    ref = newRef;
    if (!mounted)
      return;
    dispatchCreateEvent();
  };
  onMount(() => {
    dispatchCreateEvent();
    mounted = true;
  });
  onDestroy(() => {
    cleanupFunctions.forEach((cleanup) => cleanup());
  });
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useEvents.js
var isEventDispatcher = (value) => {
  return !!(value == null ? void 0 : value.addEventListener);
};
var useEvents = () => {
  const dispatch = createRawEventDispatcher();
  const component = get_current_component();
  const eventHandlerProxy = (event) => {
    if (event == null ? void 0 : event.type) {
      dispatch(event.type, event);
    }
  };
  const cleanupEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.removeEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  const addEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.addEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  const ref = writable();
  const eventNames = writable([]);
  watch([ref, eventNames], ([$ref, $eventNames]) => {
    addEventListeners($ref, $eventNames);
    return () => cleanupEventListeners($ref, $eventNames);
  });
  onMount(() => {
    eventNames.set(Object.keys(component.$$.callbacks));
  });
  const updateRef = (newRef) => {
    ref.set(newRef);
  };
  return {
    updateRef
  };
};

// node_modules/@threlte/core/dist/components/T/utils/usePlugins.js
var usePlugins = (params) => {
  const pluginContextName = "threlte-plugin-context";
  const plugins = getContext(pluginContextName);
  if (!plugins)
    return;
  const pluginsReturns = Object.values(plugins).map((plugin) => plugin(params)).filter(Boolean);
  const pluginsProps = pluginsReturns.flatMap((callback) => callback.pluginProps ?? []);
  let refCleanupCallbacks = [];
  onDestroy(() => {
    refCleanupCallbacks.forEach((callback) => callback());
  });
  const updateRef = (ref) => {
    refCleanupCallbacks.forEach((callback) => callback());
    refCleanupCallbacks = [];
    pluginsReturns.forEach((callback) => {
      var _a;
      const cleanupCallback = (_a = callback.onRefChange) == null ? void 0 : _a.call(callback, ref);
      if (cleanupCallback) {
        refCleanupCallbacks.push(cleanupCallback);
      }
    });
  };
  const updateProps = (props) => {
    pluginsReturns.forEach((callback) => {
      var _a;
      (_a = callback.onPropsChange) == null ? void 0 : _a.call(callback, props);
    });
  };
  const updateRestProps = (restProps) => {
    pluginsReturns.forEach((callback) => {
      var _a;
      (_a = callback.onRestPropsChange) == null ? void 0 : _a.call(callback, restProps);
    });
  };
  return {
    updateRef,
    updateProps,
    updateRestProps,
    pluginsProps
  };
};

// node_modules/@threlte/core/dist/components/T/utils/useProps.js
var ignoredProps = /* @__PURE__ */ new Set(["$$scope", "$$slots", "type", "args", "attach", "instance"]);
var updateProjectionMatrixKeys = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom"
]);
var memoizeProp = (value) => {
  if (typeof value === "string")
    return true;
  if (typeof value === "number")
    return true;
  if (typeof value === "boolean")
    return true;
  if (typeof value === "undefined")
    return true;
  if (value === null)
    return true;
  return false;
};
var createSetter = (target, key2, value) => {
  var _a, _b, _c;
  if (!Array.isArray(value) && typeof value === "number" && typeof ((_a = target[key2]) == null ? void 0 : _a.setScalar) === "function" && // colors do have a setScalar function, but we don't want to use it, because
  // the hex notation (i.e. 0xff0000) is very popular and matches the number
  // type. So we exclude colors here.
  !((_b = target[key2]) == null ? void 0 : _b.isColor)) {
    return (target2, key3, value2) => {
      target2[key3].setScalar(value2);
    };
  } else {
    if (typeof ((_c = target[key2]) == null ? void 0 : _c.set) === "function") {
      if (Array.isArray(value)) {
        return (target2, key3, value2) => {
          target2[key3].set(...value2);
        };
      } else {
        return (target2, key3, value2) => {
          target2[key3].set(value2);
        };
      }
    } else {
      return (target2, key3, value2) => {
        target2[key3] = value2;
      };
    }
  }
};
var useProps = () => {
  const { invalidate } = useThrelte();
  const memoizedProps = /* @__PURE__ */ new Map();
  const memoizedSetters = /* @__PURE__ */ new Map();
  const setProp = (instance6, propertyPath, value, options) => {
    if (memoizeProp(value)) {
      const memoizedProp = memoizedProps.get(propertyPath);
      if (memoizedProp && memoizedProp.instance === instance6 && memoizedProp.value === value) {
        return;
      }
      memoizedProps.set(propertyPath, {
        instance: instance6,
        value
      });
    }
    const { key: key2, target } = resolvePropertyPath(instance6, propertyPath);
    if (value !== void 0 && value !== null) {
      const memoizedSetter = memoizedSetters.get(propertyPath);
      if (memoizedSetter) {
        memoizedSetter(target, key2, value);
      } else {
        const setter = createSetter(target, key2, value);
        memoizedSetters.set(propertyPath, setter);
        setter(target, key2, value);
      }
    } else {
      createSetter(target, key2, value)(target, key2, value);
    }
    if (options.manualCamera)
      return;
    if (updateProjectionMatrixKeys.has(key2) && (target.isPerspectiveCamera || target.isOrthographicCamera)) {
      target.updateProjectionMatrix();
    }
  };
  const updateProps = (instance6, props, options) => {
    var _a;
    for (const key2 in props) {
      if (!ignoredProps.has(key2) && !((_a = options.pluginsProps) == null ? void 0 : _a.includes(key2))) {
        setProp(instance6, key2, props[key2], options);
      }
      invalidate();
    }
  };
  return {
    updateProps
  };
};

// node_modules/@threlte/core/dist/components/T/T.svelte
var get_default_slot_changes_1 = (dirty) => ({ ref: dirty & /*ref*/
2 });
var get_default_slot_context_1 = (ctx) => ({ ref: (
  /*ref*/
  ctx[1]
) });
var get_default_slot_changes = (dirty) => ({ ref: dirty & /*ref*/
2 });
var get_default_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[1]
) });
function create_if_block_1(ctx) {
  let disposableobject;
  let current;
  disposableobject = new DisposableObject_default({
    props: {
      object: (
        /*ref*/
        ctx[1]
      ),
      dispose: (
        /*dispose*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(disposableobject.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject_changes = {};
      if (dirty & /*ref*/
      2) disposableobject_changes.object = /*ref*/
      ctx2[1];
      if (dirty & /*dispose*/
      1) disposableobject_changes.dispose = /*dispose*/
      ctx2[0];
      disposableobject.$set(disposableobject_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(disposableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(70:0) {#if isDisposableObject(ref)}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context_1
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        2050)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes_1
            ),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(81:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let scenegraphobject;
  let current;
  scenegraphobject = new SceneGraphObject_default({
    props: {
      object: (
        /*ref*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scenegraphobject.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(scenegraphobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const scenegraphobject_changes = {};
      if (dirty & /*ref*/
      2) scenegraphobject_changes.object = /*ref*/
      ctx2[1];
      if (dirty & /*$$scope, ref*/
      2050) {
        scenegraphobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scenegraphobject.$set(scenegraphobject_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(scenegraphobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scenegraphobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scenegraphobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(77:0) {#if extendsObject3D(ref)}",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        2050)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(78:2) <SceneGraphObject object={ref}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let show_if_1 = isDisposableObject(
    /*ref*/
    ctx[1]
  );
  let t;
  let show_if;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let if_block0 = show_if_1 && create_if_block_1(ctx);
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*ref*/
    2) show_if = null;
    if (show_if == null) show_if = !!extendsObject3D(
      /*ref*/
      ctx2[1]
    );
    if (show_if) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*ref*/
      2) show_if_1 = isDisposableObject(
        /*ref*/
        ctx2[1]
      );
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*ref*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0) if_block0.d(detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["is", "args", "attach", "manual", "makeDefault", "dispose", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("T", slots, ["default"]);
  let { is } = $$props;
  let { args = void 0 } = $$props;
  let { attach = void 0 } = $$props;
  let { manual = void 0 } = $$props;
  let { makeDefault = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(9, $parent = value));
  const createEvent = useCreateEvent();
  let ref = determineRef(is, args);
  createEvent.updateRef(ref);
  let initialized = false;
  const maybeSetRef = () => {
    if (!initialized) {
      initialized = true;
      return;
    }
    $$invalidate(1, ref = determineRef(is, args));
    createEvent.updateRef(ref);
  };
  let { ref: publicRef = ref } = $$props;
  const parentContext = createParentContext(ref);
  const plugins = usePlugins({ ref, props: $$props });
  const pluginsProps = (plugins == null ? void 0 : plugins.pluginsProps) ?? [];
  const props = useProps();
  const camera = useCamera();
  const attachment = useAttach();
  const events = useEvents();
  $$self.$$.on_mount.push(function() {
    if (is === void 0 && !("is" in $$props || $$self.$$.bound[$$self.$$.props["is"]])) {
      console.warn("<T> was created without expected prop 'is'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("is" in $$new_props) $$invalidate(4, is = $$new_props.is);
    if ("args" in $$new_props) $$invalidate(5, args = $$new_props.args);
    if ("attach" in $$new_props) $$invalidate(6, attach = $$new_props.attach);
    if ("manual" in $$new_props) $$invalidate(7, manual = $$new_props.manual);
    if ("makeDefault" in $$new_props) $$invalidate(8, makeDefault = $$new_props.makeDefault);
    if ("dispose" in $$new_props) $$invalidate(0, dispose = $$new_props.dispose);
    if ("ref" in $$new_props) $$invalidate(3, publicRef = $$new_props.ref);
    if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DisposableObject: DisposableObject_default,
    SceneGraphObject: SceneGraphObject_default,
    createParentContext,
    useParent,
    determineRef,
    extendsObject3D,
    isDisposableObject,
    useAttach,
    useCamera,
    useCreateEvent,
    useEvents,
    usePlugins,
    useProps,
    is,
    args,
    attach,
    manual,
    makeDefault,
    dispose,
    parent,
    createEvent,
    ref,
    initialized,
    maybeSetRef,
    publicRef,
    parentContext,
    plugins,
    pluginsProps,
    props,
    camera,
    attachment,
    events,
    $parent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("is" in $$props) $$invalidate(4, is = $$new_props.is);
    if ("args" in $$props) $$invalidate(5, args = $$new_props.args);
    if ("attach" in $$props) $$invalidate(6, attach = $$new_props.attach);
    if ("manual" in $$props) $$invalidate(7, manual = $$new_props.manual);
    if ("makeDefault" in $$props) $$invalidate(8, makeDefault = $$new_props.makeDefault);
    if ("dispose" in $$props) $$invalidate(0, dispose = $$new_props.dispose);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    if ("initialized" in $$props) initialized = $$new_props.initialized;
    if ("publicRef" in $$props) $$invalidate(3, publicRef = $$new_props.publicRef);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*is, args*/
    48) {
      $: is, args, maybeSetRef();
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $: $$invalidate(3, publicRef = ref);
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $: parentContext.set(ref);
    }
    $: props.updateProps(ref, $$restProps, { manualCamera: manual, pluginsProps });
    if ($$self.$$.dirty & /*ref, manual*/
    130) {
      $: camera.update(ref, manual);
    }
    if ($$self.$$.dirty & /*ref, makeDefault*/
    258) {
      $: camera.makeDefaultCamera(ref, makeDefault);
    }
    if ($$self.$$.dirty & /*ref, $parent, attach*/
    578) {
      $: attachment.update(ref, $parent, attach);
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $: events.updateRef(ref);
    }
    if ($$self.$$.dirty & /*ref*/
    2) {
      $: plugins == null ? void 0 : plugins.updateRef(ref);
    }
    $: plugins == null ? void 0 : plugins.updateProps($$props);
    $: plugins == null ? void 0 : plugins.updateRestProps($$restProps);
  };
  $$props = exclude_internal_props($$props);
  return [
    dispose,
    ref,
    parent,
    publicRef,
    is,
    args,
    attach,
    manual,
    makeDefault,
    $parent,
    slots,
    $$scope
  ];
}
var T = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      is: 4,
      args: 5,
      attach: 6,
      manual: 7,
      makeDefault: 8,
      dispose: 0,
      ref: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "T",
      options,
      id: create_fragment5.name
    });
  }
  get is() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set is(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get args() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set args(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get attach() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set attach(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get manual() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set manual(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get makeDefault() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set makeDefault(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dispose() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dispose(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<T>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<T>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var T_default = T;

// node_modules/@threlte/core/dist/components/T/T.js
var catalogue = {};
var extend = (extensions) => {
  Object.assign(catalogue, extensions);
};
var augmentConstructorArgs = (args, is) => {
  const module = catalogue[is] || three_module_exports[is];
  if (!module) {
    throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);
  }
  return {
    ...args,
    props: {
      ...args.props,
      is: module
    }
  };
};
var proxyTConstructor = (is) => {
  return new Proxy(class {
  }, {
    construct(_, [args]) {
      const castedArgs = args;
      return new T_default(augmentConstructorArgs(castedArgs, is));
    }
  });
};
var T2 = new Proxy(class {
}, {
  construct(_, [args]) {
    const castedArgs = args;
    return new T_default(castedArgs);
  },
  get(_, is) {
    return proxyTConstructor(is);
  }
});

// node_modules/@threlte/core/dist/plugins/injectPlugin.js
function injectPlugin(nameOrNamedPlugin, maybePlugin) {
  const contextName2 = "threlte-plugin-context";
  if (Array.isArray(nameOrNamedPlugin)) {
    const [name, plugin] = nameOrNamedPlugin;
    setContext(contextName2, {
      ...getContext(contextName2),
      [name]: plugin
    });
  } else {
    const name = nameOrNamedPlugin;
    const plugin = maybePlugin;
    if (!plugin)
      return;
    setContext(contextName2, {
      ...getContext(contextName2),
      [name]: plugin
    });
  }
}

// node_modules/@threlte/core/dist/plugins/createPlugin.js
function createPlugin(name, plugin) {
  return [name, plugin];
}

// node_modules/@threlte/core/dist/hooks/useTask.js
function useTask(keyOrFn, fnOrOptions, options) {
  if (!browser) {
    return {
      task: void 0,
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  let key2;
  let fn;
  let opts;
  if (DAG.isKey(keyOrFn)) {
    key2 = keyOrFn;
    fn = fnOrOptions;
    opts = options;
  } else {
    key2 = Symbol("useTask");
    fn = keyOrFn;
    opts = fnOrOptions;
  }
  const ctx = useThrelte();
  let stage = ctx.mainStage;
  if (opts) {
    if (opts.stage) {
      if (DAG.isValue(opts.stage)) {
        stage = opts.stage;
      } else {
        const maybeStage = ctx.scheduler.getStage(opts.stage);
        if (!maybeStage) {
          throw new Error(`No stage found with key ${opts.stage.toString()}`);
        }
        stage = maybeStage;
      }
    } else if (opts.after) {
      if (Array.isArray(opts.after)) {
        for (let index = 0; index < opts.after.length; index++) {
          const element2 = opts.after[index];
          if (DAG.isValue(element2)) {
            stage = element2.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.after)) {
        stage = opts.after.stage;
      }
    } else if (opts.before) {
      if (Array.isArray(opts.before)) {
        for (let index = 0; index < opts.before.length; index++) {
          const element2 = opts.before[index];
          if (DAG.isValue(element2)) {
            stage = element2.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.before)) {
        stage = opts.before.stage;
      }
    }
  }
  const { autoInvalidations } = getContext("threlte-internal-context");
  const started = writable(false);
  const task = stage.createTask(key2, fn, opts);
  const start = () => {
    started.set(true);
    if ((opts == null ? void 0 : opts.autoInvalidate) ?? true) {
      autoInvalidations.add(fn);
    }
    task.start();
  };
  const stop = () => {
    started.set(true);
    if ((opts == null ? void 0 : opts.autoInvalidate) ?? true) {
      autoInvalidations.delete(fn);
    }
    task.stop();
  };
  if ((opts == null ? void 0 : opts.autoStart) ?? true) {
    start();
  } else {
    stop();
  }
  onDestroy(() => {
    if (!stage)
      return;
    stage.removeTask(key2);
  });
  return {
    task,
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
}

// node_modules/@threlte/core/dist/hooks/useStage.js
function useStage(key2, options) {
  const { scheduler } = useThrelte();
  return scheduler.getStage(key2) ?? scheduler.createStage(key2, options);
}

// node_modules/@threlte/core/dist/hooks/useThrelteUserContext.js
function useThrelteUserContext(namespace, value, options) {
  const userCtxStore = getContext("threlte-user-context");
  if (!userCtxStore) {
    throw new Error("No user context store found, did you invoke this function outside of your main <Canvas> component?");
  }
  if (!namespace) {
    return {
      subscribe: userCtxStore.subscribe
    };
  }
  if (namespace && !value) {
    return derived(userCtxStore, (ctx) => ctx[namespace]);
  }
  userCtxStore.update((ctx) => {
    if (namespace in ctx) {
      if (!options || options.existing === "skip")
        return ctx;
      if (options.existing === "merge") {
        Object.assign(ctx[namespace], value);
        return ctx;
      }
    }
    ctx[namespace] = value;
    return ctx;
  });
  return userCtxStore.current[namespace];
}

// node_modules/@threlte/core/dist/hooks/legacy/useFrame.js
var orderToKey2 = (order) => `useFrame-order-${order.toString()}`;
var useFrame = (fn, options) => {
  if (!browser) {
    return {
      start: () => void 0,
      stop: () => void 0,
      started: readable(false)
    };
  }
  const started = writable(false);
  const ctx = useThrelte();
  const { useFrameOrders } = useLegacyFrameCompatibilityContext();
  const { autoInvalidations } = getContext("threlte-internal-context");
  let order = (options == null ? void 0 : options.order) ?? 0;
  while (useFrameOrders.includes(order)) {
    order += 0.01;
  }
  useFrameOrders.push(order);
  const key2 = orderToKey2(order);
  const proxy = (delta) => {
    fn(ctx, delta);
  };
  const task = ctx.mainStage.createTask(key2, proxy, {
    after: useFrameOrders.filter((o) => o < order).map((o) => orderToKey2(o)),
    before: useFrameOrders.filter((o) => o > order).map((o) => orderToKey2(o))
  });
  const start = () => {
    started.set(true);
    if ((options == null ? void 0 : options.invalidate) ?? true) {
      autoInvalidations.add(fn);
    }
    task.start();
  };
  const stop = () => {
    started.set(true);
    if ((options == null ? void 0 : options.invalidate) ?? true) {
      autoInvalidations.delete(fn);
    }
    task.stop();
  };
  if ((options == null ? void 0 : options.autostart) ?? true) {
    start();
  } else {
    stop();
  }
  onDestroy(() => {
    ctx.mainStage.removeTask(key2);
    useFrameOrders.splice(useFrameOrders.indexOf(order), 1);
  });
  return {
    start,
    stop,
    started: {
      subscribe: started.subscribe
    }
  };
};

// node_modules/@threlte/core/dist/hooks/legacy/useRender.js
var useRender = (fn, options) => {
  if (!browser) {
    return;
  }
  const ctx = useThrelte();
  const { useRenderOrders } = useLegacyFrameCompatibilityContext();
  let order = (options == null ? void 0 : options.order) ?? 0;
  while (useRenderOrders.includes(order)) {
    order += 0.01;
  }
  useRenderOrders.push(order);
  const key2 = orderToKey(order);
  const proxy = (delta) => {
    fn(ctx, delta);
  };
  ctx.renderStage.createTask(key2, proxy, {
    after: useRenderOrders.filter((o) => o < order).map((o) => orderToKey(o)),
    before: useRenderOrders.filter((o) => o > order).map((o) => orderToKey(o))
  });
  onDestroy(() => {
    ctx.renderStage.removeTask(key2);
    useRenderOrders.splice(useRenderOrders.indexOf(order), 1);
  });
};

// node_modules/@threlte/core/dist/lib/asyncWritable.js
var asyncWritable = (promise) => {
  const store = writable(void 0);
  const error = writable(void 0);
  promise.then((result) => {
    store.set(result);
  }).catch((e) => {
    console.error("Error in asyncWritable:", e.message);
    error.set(e);
  });
  return Object.assign(Object.assign(promise, store), { error, promise });
};

// node_modules/@threlte/core/dist/hooks/useLoader.js
function useLoader(Proto, options) {
  const { remember, clear: clearCacheItem } = useCache();
  let loader;
  const initializeLoader = () => {
    var _a;
    const lazyLoader = new Proto(...(options == null ? void 0 : options.args) ?? []);
    (_a = options == null ? void 0 : options.extend) == null ? void 0 : _a.call(options, lazyLoader);
    return lazyLoader;
  };
  const load = (input, options2) => {
    const loadResource = async (url) => {
      var _a;
      if (!loader) {
        loader = initializeLoader();
      }
      if ("loadAsync" in loader) {
        const result = await loader.loadAsync(url, options2 == null ? void 0 : options2.onProgress);
        return ((_a = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a.call(options2, result)) ?? result;
      } else {
        return new Promise((resolve, reject) => {
          ;
          loader.load(url, (data) => {
            var _a2;
            return resolve(((_a2 = options2 == null ? void 0 : options2.transform) == null ? void 0 : _a2.call(options2, data)) ?? data);
          }, (event) => {
            var _a2;
            return (_a2 = options2 == null ? void 0 : options2.onProgress) == null ? void 0 : _a2.call(options2, event);
          }, reject);
        });
      }
    };
    if (Array.isArray(input)) {
      const promises = input.map((url) => {
        return remember(() => loadResource(url), [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises));
      return store;
    } else if (typeof input === "string") {
      const promise = remember(() => loadResource(input), [Proto, input]);
      const store = asyncWritable(promise);
      return store;
    } else {
      const promises = Object.values(input).map((url) => {
        return remember(() => loadResource(url), [Proto, url]);
      });
      const store = asyncWritable(Promise.all(promises).then((results) => {
        return Object.fromEntries(Object.entries(input).map(([key2], i) => [key2, results[i]]));
      }));
      return store;
    }
  };
  const clear = (input) => {
    if (Array.isArray(input)) {
      input.forEach((url) => {
        clearCacheItem([Proto, url]);
      });
    } else if (typeof input === "string") {
      clearCacheItem([Proto, input]);
    } else {
      Object.entries(input).forEach(([key2, url]) => {
        clearCacheItem([Proto, key2, url]);
      });
    }
  };
  return {
    load,
    clear,
    loader
  };
}

// node_modules/@threlte/core/dist/lib/forwardEventHandlers.js
var forwardEventHandlers = () => {
  const component = get_current_component();
  const dispatchingComponent = writable(void 0);
  watch(dispatchingComponent, (dispatchingComponent2) => {
    if (!dispatchingComponent2)
      return;
    Object.entries(component.$$.callbacks).forEach((callback) => {
      const [key2, value] = callback;
      if (key2 in dispatchingComponent2.$$.callbacks && Array.isArray(dispatchingComponent2.$$.callbacks[key2])) {
        dispatchingComponent2.$$.callbacks[key2].push(...value);
      } else {
        dispatchingComponent2.$$.callbacks[key2] = value;
      }
    });
  });
  return dispatchingComponent;
};

export {
  watch,
  memoize,
  currentWritable,
  createThrelteContext,
  createObjectStore,
  useThrelte,
  useParent,
  HierarchicalObject_default,
  SceneGraphObject_default,
  useCache,
  revision,
  Canvas_default,
  DisposableObject_default,
  resolvePropertyPath,
  createRawEventDispatcher,
  extend,
  T2 as T,
  injectPlugin,
  createPlugin,
  useTask,
  useStage,
  useThrelteUserContext,
  useFrame,
  useRender,
  asyncWritable,
  useLoader,
  forwardEventHandlers
};
//# sourceMappingURL=chunk-KHLT5OU7.js.map
